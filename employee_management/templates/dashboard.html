{% extends 'base.html' %}
{% load static %}
{% load custom_filters %}
{% load timedelta_filters %}
{% load duration_filters %}
{% csrf_token %}
{% block content %}


{% block extra_head %}
<style>
  .main-content {
    margin-left: 0px;
    transition: margin-left 0.3s ease;
  }

  .content-area {
    margin-top: 64px;
    overflow: auto;
    height: calc(100vh - 64px);
  }

  /* Break toggle animation */
  .peer-checked:after:translate-x-full {
    transform: translateX(100%);
  }

  /* Status text animation */
  @keyframes statusPing {
    75%, 100% {
      transform: scale(2);
      opacity: 0;
    }
  }

  .status-ping::after {
    content: '';
    position: absolute;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background-color: currentColor;
    animation: statusPing 1s cubic-bezier(0, 0, 0.2, 1) infinite;
  }

  /* Call Details Table specific styles */
.call-details-table {
    border-collapse: separate;
    border-spacing: 0;
}

.call-details-table thead th {
    background-color: #F3F4F6;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
}

.call-details-table tbody tr:last-child {
    border-bottom: none;
}

/* Hover effect */
.call-details-table tbody tr:hover {
    background-color: #F9FAFB;
    transition: background-color 0.2s ease;
}

/* Responsive padding for mobile */
@media (max-width: 640px) {
    .call-details-table th,
    .call-details-table td {
        padding: 0.75rem 0.5rem;
    }
}

/* Right Sidebar Styles */
#rightSidebar {
    width: 400px;
    box-shadow: -2px 0 10px rgba(0,0,0,0.1);
}

/* Chart Container Styles */
.chart-container {
    position: relative;
    height: 300px;
}

/* Summary Section Hover Effects */
.bg-gray-100:hover {
    background-color: #f7fafc;
    transition: background-color 0.3s ease;
}

/* Data Table Hover Effects */
#dataTable tr:hover {
    background-color: #f9fafb;
}

/* Responsive Adjustments */
@media (max-width: 768px) {
    #rightSidebar {
        width: 100%;
    }
}

/* Priority Colors */
td[data-priority="urgent"] {
    background-color: #ef4444 !important; /* red-500 */
    color: white !important;
}

td[data-priority="high"] {
    background-color: #f97316 !important; /* orange-500 */
    color: white !important;
}

td[data-priority="medium"] {
    background-color: #facc15 !important; /* yellow-400 */
    color: #713f12 !important; /* yellow-900 */
}

td[data-priority="low"] {
    background-color: #22c55e !important; /* green-500 */
    color: white !important;
}

/* Status Colors */
td[data-status="open"] {
    background-color: #ff9800 !important; /* Original pie chart orange */
    color: white !important;
}

td[data-status="pending"] {
    background-color: #eed910 !important; /* Original pie chart yellow */
    color: white !important;
}

td[data-status="resolved"] {
    background-color: #93ee10 !important; /* Original pie chart light green */
    color: white !important;
}

td[data-status="closed"] {
    background-color: #10ee38 !important; /* Original pie chart green */
    color: white !important;
}

td[data-status="waiting_on_customer"] {
    background-color: #ea3610 !important; /* Original pie chart red-orange */
    color: white !important;
}

td[data-status="initial_response"] {
    background-color: #1035ee !important; /* Original pie chart blue */
    color: white !important;
}

td[data-status="on_hold"] {
    background-color: #10cfee !important; /* Original pie chart light blue */
    color: white !important;
}


/* Time Display Styles */
.created-timer-span {
    display: inline-block;
    padding: 0.25rem 0.5rem;
    font-family: monospace;
}

/* Break button Styling */
.status-indicator {
    display: flex;
    align-items: center;
    gap: 8px;
}

.status-text {
    font-size: 14px;
    font-weight: 500;
    position: relative;
}

.status-text.active {
    color: #28a745;
}

.status-text.break {
    color: #dc3545;
}

.status-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    display: inline-block;
    position: relative;
}

.status-text.active + .status-dot {
    background-color: #28a745;
    animation: pulse-green 2s infinite;
}

.status-text.break + .status-dot {
    background-color: #dc3545;
    animation: pulse-red 2s infinite;
}

@keyframes pulse-green {
    0% {
        box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.4);
    }
    70% {
        box-shadow: 0 0 0 10px rgba(40, 167, 69, 0);
    }
    100% {
        box-shadow: 0 0 0 0 rgba(40, 167, 69, 0);
    }
}

@keyframes pulse-red {
    0% {
        box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.4);
    }
    70% {
        box-shadow: 0 0 0 10px rgba(220, 53, 69, 0);
    }
    100% {
        box-shadow: 0 0 0 0 rgba(220, 53, 69, 0);
    }
}


























/* Time Column Base Styles */
.time-column {
    transition: all 0.3s ease;
    position: relative;
}

.timer-span {
    position: relative;
    z-index: 2;
}

/* Priority-based Animations */
@keyframes pulse-urgent {
    0% {
        background-color: rgba(239, 68, 68, 0.7); /* #ef4444 with opacity */
        color: white;
    }
    50% {
        background-color: rgba(239, 68, 68, 0.9); /* #ef4444 with higher opacity */
        color: white;
    }
    100% {
        background-color: rgba(239, 68, 68, 0.7); /* #ef4444 with opacity */
        color: white;
    }
}

@keyframes pulse-high {
    0% {
        background-color: rgba(249, 115, 22, 0.7); /* #f97316 with opacity */
        color: white;
    }
    50% {
        background-color: rgba(249, 115, 22, 0.9); /* #f97316 with higher opacity */
        color: white;
    }
    100% {
        background-color: rgba(249, 115, 22, 0.7); /* #f97316 with opacity */
        color: white;
    }
}

@keyframes pulse-medium {
    0% {
        background-color: rgba(250, 204, 21, 0.7); /* #facc15 with opacity */
        color: #713f12;
    }
    50% {
        background-color: rgba(250, 204, 21, 0.9); /* #facc15 with higher opacity */
        color: #713f12;
    }
    100% {
        background-color: rgba(250, 204, 21, 0.7); /* #facc15 with opacity */
        color: #713f12;
    }
}

@keyframes pulse-low {
    0% {
        background-color: rgba(34, 197, 94, 0.7); /* #22c55e with opacity */
        color: white;
    }
    50% {
        background-color: rgba(34, 197, 94, 0.9); /* #22c55e with higher opacity */
        color: white;
    }
    100% {
        background-color: rgba(34, 197, 94, 0.7); /* #22c55e with opacity */
        color: white;
    }
}

/* Total Time Column Priority Styles */
.time-column.total-time.priority-urgent {
    animation: pulse-urgent 2s infinite !important;
}

.time-column.total-time.priority-high {
    animation: pulse-high 2s infinite !important;
}

.time-column.total-time.priority-medium {
    animation: pulse-medium 2s infinite !important;
}

.time-column.total-time.priority-low {
    animation: pulse-low 2s infinite !important;
}

/* Individual Time Column Priority Styles */
.time-column.individual-time.exceeded.priority-urgent {
    animation: pulse-urgent 2s infinite;
}

.time-column.individual-time.exceeded.priority-high {
    animation: pulse-high 2s infinite;
}

.time-column.individual-time.exceeded.priority-medium {
    animation: pulse-medium 2s infinite;
}

.time-column.individual-time.exceeded.priority-low {
    animation: pulse-low 2s infinite;
}



/* Notifications Styling */
.notifications-popup {
    background: #ffffff !important;
    border-radius: 12px !important;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15) !important;
    margin-top: 20px !important;
}

.notifications-container {
    max-height: 80vh;
    overflow-y: auto;
}

.notifications-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 20px;
    border-bottom: 1px solid #eee;
    background: #f8f9fa;
    border-radius: 12px 12px 0 0;
}

.notifications-header h4 {
    margin: 0;
    color: #2c3e50;
    font-size: 1.1rem;
    font-weight: 600;
}

.notifications-list {
    padding: 10px;
}

.notification-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px;
    margin-bottom: 8px;
    border-radius: 8px;
    background: white;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    animation: slideIn 0.3s ease-out;
}

.notification-content {
    flex: 1;
    margin-right: 10px;
}

.notification-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 5px;
}

.ticket-id {
    font-weight: 600;
    color: #2c3e50;
}

.priority-badge {
    padding: 3px 8px;
    border-radius: 12px;
    font-size: 0.8rem;
    font-weight: 500;
}

.priority-badge.urgent { background: #ff4444; color: white; }
.priority-badge.high { background: #ffbb33; color: black; }
.priority-badge.medium { background: #ff8800; color: white; }
.priority-badge.low { background: #00C851; color: white; }

.notification-body {
    font-size: 0.9rem;
}

.subject {
    color: #2c3e50;
    margin-bottom: 3px;
}

.time-exceeded {
    color: #666;
    font-size: 0.8rem;
}

.dismiss-ticket, .dismiss-all {
    background: none;
    border: none;
    padding: 5px;
    cursor: pointer;
    transition: opacity 0.2s;
}

.dismiss-ticket:hover, .dismiss-all:hover {
    opacity: 0.7;
}

.dismiss-all {
    background: #e74c3c;
    color: white;
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 0.9rem;
}

@keyframes slideIn {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
}

@keyframes slideOut {
    from { transform: translateX(0); opacity: 1; }
    to { transform: translateX(100%); opacity: 0; }
}


.ticket-notification {
    background-color: #fff;
    border: 1px solid #ddd;
    border-left: 4px solid #0d6efd;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    margin-bottom: 10px;
    padding: 15px;
    width: 350px;
}

#notification-container {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 1050;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.ticket-notification .notification-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.ticket-notification .notification-body {
    margin-bottom: 10px;
}

.ticket-notification .notification-actions {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
}


.ticket-alert {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 1050;
    width: 350px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    border-left: 4px solid #0366d6;
    animation: slideIn 0.5s ease-out;
}

.ticket-alert.priority-urgent {
    border-left-color: #dc3545;
}

.ticket-alert.priority-high {
    border-left-color: #fd7e14;
}

.alert-header {
    padding: 12px 15px;
    border-bottom: 1px solid #e1e4e8;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.alert-body {
    padding: 15px;
}

.alert-actions {
    padding: 10px 15px;
    border-top: 1px solid #e1e4e8;
    display: flex;
    justify-content: flex-end;
    gap: 10px;
}

@keyframes slideIn {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

.notification-item .message {
    color: #666;
    font-size: 0.9rem;
    margin-top: 5px;
}

.notification-actions {
    display: flex;
    gap: 8px;
    align-items: center;
}

.notification-item {
    border-left: 4px solid transparent;
}

.notification-item.priority-urgent { border-left-color: #ff4444; }
.notification-item.priority-high { border-left-color: #ffbb33; }
.notification-item.priority-medium { border-left-color: #ff8800; }
.notification-item.priority-low { border-left-color: #00C851; }

/* Add to your existing CSS */
.acknowledge-button {
    transition: all 0.3s ease;
}

.acknowledge-button:disabled {
    cursor: not-allowed;
    opacity: 0.7;
}

.acknowledge-button .fa-spinner {
    margin-right: 5px;
}

.text-success {
    transition: opacity 0.3s ease;
}


.my-swal-popup {
    width: auto !important;
    max-width: 600px;
}

.my-swal pre {
    background-color: #f8f9fa;
    padding: 15px;
    border-radius: 5px;
    margin: 10px 0;
    font-size: 14px;
    white-space: pre-wrap;
    word-wrap: break-word;
    max-height: 300px;
    overflow-y: auto;
}

.my-swal .alert {
    text-align: left;
    margin-bottom: 0;
}



    .tooltip {
    visibility: hidden;
    position: absolute;
    z-index: 50;
  }

  .has-tooltip:hover .tooltip {
    visibility: visible;
  }

  /* For timer animations */
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: .5; }
  }

  .animate-pulse {
    animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
  }

  /* Preserve existing functionality styles */
  .start-button.paused-by-call,
  .start-button.blocked {
    opacity: 0.7;
    cursor: not-allowed !important;
    background-color: #6c757d !important;
    border-color: #6c757d !important;
    pointer-events: all !important;
  }

    /* Add these styles */
.call-action-form {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100%;
    margin: 0;  /* Add this */
    padding: 0;  /* Add this */
}

.call-action-form button,
.start-button {
    height: 32px;  /* Fixed height to match */
    display: inline-flex;
    align-items: center;
    justify-content: center;
}

/* Style both buttons the same way */
.start-button,
.call-action-form button {
    border: 1px solid;
    padding: 0.25rem 0.75rem;
    border-radius: 0.25rem;
    font-size: 0.875rem;
    line-height: 1.25;
}

/* Start button specific styles */
.start-button {
    color: #22c55e !important;
    background-color: #dcfce7 !important;
    border-color: #22c55e !important;
    min-width: 70px;
}

/* Call button specific styles */
.call-action-form button {
    margin: 0 !important;  /* Add this */
    height: 32px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0.25rem 0.75rem;
    border-radius: 0.25rem;
    font-size: 0.875rem;
    color: white !important;
    background-color: #9ca3af !important;
    border: 1px solid #9ca3af !important;
    min-width: 70px;
    line-height: 1;  /* Add this */
}


/* Button Container Styles */
.call-action-form {
    display: flex;
    justify-content: center;
    align-items: center;
}

/* Base Button Styles */
.start-button,
.call-action-form button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0.25rem 0.75rem;
    border-radius: 0.25rem;
    font-size: 0.875rem;
    height: 32px;
    border: 1px solid;
    cursor: pointer;
    transition: all 0.2s ease;
}

/* Start Button */
.start-button {
    color: #22c55e !important;
    background-color: #dcfce7 !important;
    border-color: #22c55e !important;
    min-width: 80px;
}








.max-w-full.mx-auto.bg-white {
    padding: .5rem;
    margin: 0;
    width: 100%;
    border-radius: 0.5rem;
}


.text-sm th {
    text-align: center !important;
}

.text-sm th{
    padding: 0.75rem !important;
    vertical-align: middle !important;
    white-space: nowrap;
}



</style>

{% endblock %}





<!-- Dashboard Page -->
<div class="main-content">
<div class="p-1 content-area">
<div class="max-w-full mx-auto bg-white p-6 shadow-lg rounded-lg overflow-x-auto">
    <div class="flex justify-between items-center mb-7">
        <h1 class="text-4xl font-medium">{{user.username}}'s Dashboard</h1>
            <div class="break-toggle-container">
                <form action="{% url 'toggle_break_status' %}" method="post" id="breakToggleForm" class="d-flex align-items-center" onsubmit="return false;">
                {% csrf_token %}
                    <div class="status-toggle-wrapper">
                        <label class="modern-switch">
                            <input type="checkbox" id="breakToggle" {% if employee_profile.is_on_break %}checked{% endif %}>
                            <span class="modern-slider">
                            <span class="toggle-circle"></span>
                            </span>
                        </label>
                        <div class="status-indicator">
                            <span id="breakStatus" class="status-text {% if employee_profile.is_on_break %}break{% else %}active{% endif %}">
                                {% if employee_profile.is_on_break %}
                                On Break
                                {% else %}
                                Active
                                {% endif %}
                            </span>
                    <span class="status-dot"></span>
                </div>
            </div>
        </form>
    </div>
</div>

    <!-- Ticket Table with Actions -->

  <div class="max-w-full mx-auto bg-white shadow-lg rounded-lg">
      <h1 class="text-2xl font-bold mb-6">Tickets Table</h1>

    <table class="w-full border-collapse border border-gray-300">
      <thead class="text-sm">
        <tr class="bg-blue-200">
          <th class="border p-1"></th>
          <th class="border p-1">Ticket ID</th>
          <th class="border p-1">Subject</th>
          <th class="border p-1">Priority</th>
          <th class="border p-1">Status</th>
          <th class="border p-1">Ticket Age</th>
          <th class="border p-1">Total Effort</th>
          <th class="border p-1">Individual Effort</th>
          <th class="border p-1">Action</th>
          <th class="border p-1">On Call</th>
          <th class="border p-1">Accept</th>
        </tr>
      </thead>
      <tbody class="text-center">
        {% for ticket in tickets %}
          {% if ticket.status != 'closed' and ticket.status != 'resolved' %}
          <!-- Empty row for spacing -->
          <tr><td colspan="11" class="h-1"></td></tr>

          <!-- Main Ticket Row -->
          <tr class="border border-l-4 border-blue-500 bg-gray-100 hover:bg-gray-200"
              data-ticket-id="{{ ticket.id }}"
              data-priority="{{ ticket.priority|lower }}"
              data-created-at="{{ ticket.created_at|date:'Y-m-d H:i:s' }}">

            <td class="border px-2 py-1 text-center cursor-pointer" onclick="toggleRow(this)">+</td>
            <td class="border px-2 py-1">{{ ticket.ticket_id }}</td>
            <td class="border px-2 py-1 text-left has-tooltip relative cursor-pointer">
              {{ ticket.subject }}
            </td>
            <td class="border px-2 py-1" data-priority="{{ ticket.priority|lower }}">
                {{ ticket.priority }}
            </td>
            <td class="border px-2 py-1" data-status="{{ ticket.status|lower }}">
                {{ ticket.status|status_abbreviation }}
            </td>
            <td class="border px-2 py-1 text-center">
                <span id="created-timer-{{ ticket.id }}"
                      class="created-timer-span priority-{{ ticket.priority|lower }}"
                      data-created-at="{{ ticket.created_at|localize_datetime|date:'c' }}"
                      data-status="{{ ticket.status }}"
                      data-priority="{{ ticket.priority|lower }}"
                      title="Created: {{ ticket.created_at|date:'F j, Y, g:i a' }}">
                    {{ ticket.time_since_created }}
                </span>
            </td>
            <!-- Replace your existing Total Spent column with this -->
            <td class="border px-2 py-1 text-center time-column total-time {% if ticket.has_exceeded_time_limit %}priority-{{ ticket.priority|lower }}{% endif %}">
                <span id="timer-{{ ticket.id }}"
                      class="timer-span"
                      data-ticket-id="{{ ticket.id }}">
                    {{ ticket.time_spent|format_duration }}
                </span>
            </td>

<!-- Replace your existing Individual Spent column with this -->
            <td class="border px-2 py-1 text-center time-column individual-time {% if ticket.has_exceeded_time_limit and not ticket.status_changed %}exceeded priority-{{ ticket.priority|lower }}{% endif %}">
                <span id="individual-timer-{{ ticket.id }}"
                      class="timer-span"
                      data-ticket-id="{{ ticket.id }}">
                    {{ ticket.individual_time_spent|format_duration }}
                </span>
            </td>
            <td class="border px-2 py-1 text-center">
                <input type="hidden" name="csrfmiddlewaretoken" value="{{ csrf_token }}">
                <button class="start-button" data-ticket-id="{{ ticket.id }}">
                    {% if ticket.is_active %}Stop{% else %}Start{% endif %}
                </button>
            </td>
            <td class="border px-2 py-1 text-center" style="vertical-align: middle;">
                <form method="post" action="{% url 'start_end_call' ticket.id %}"
                      class="call-action-form" data-ticket-id="{{ ticket.id }}">
                    {% csrf_token %}
                    {% if ticket.call_in_progress %}
                        <input type="hidden" name="action" value="end_call">
                        <button type="submit">End Call</button>
                    {% else %}
                        <input type="hidden" name="action" value="start_call">
                        <button type="submit">Start Call</button>
                    {% endif %}
                </form>
            </td>
            <td class="border px-2 py-1 text-center">
              {% if ticket.assigned_to == request.user %}
                {% if not ticket.is_acknowledged %}
                  <button class="btn btn-primary btn-sm acknowledge-button"
                          data-ticket-id="{{ ticket.id }}"
                          data-acknowledge-button="true"
                          onclick="notificationManager.acknowledgeTicket({{ ticket.id }}); return false;">
                    Accept
                  </button>
                {% else %}
                  <span class="text-success">✅</span>
                {% endif %}
              {% endif %}
            </td>
          </tr>

          <!-- Expanded Row -->
          <tr class="hidden text-left bg-gray-100" id="expanded-row-{{ ticket.id }}">
            <td colspan="11" class="py-2 px-4">
              <a href="{% url 'assign_ticket' ticket.id %}"
                 class="text-white bg-blue-700 hover:bg-blue-800 focus:ring-1 focus:ring-blue-300 font-medium text-sm px-5 py-2.5 me-2 mb-2">
                Assign
              </a>

              <div class="dropdown inline-block">
                <button class="text-white bg-blue-700 hover:bg-blue-800 focus:ring-1 focus:ring-blue-300 font-medium text-sm px-5 py-2.5 me-2 mb-2"
                        id="statusDropdown-{{ ticket.id }}"
                        data-bs-toggle="dropdown"
                        aria-expanded="false">
                  Change Status
                </button>
<!--                <ul class="dropdown-menu" aria-labelledby="statusDropdown-{{ ticket.id }}">-->
<!--                  {% for status in ticket_statuses %}-->
<!--                    {% if status.0 != ticket.status %}-->
<!--                      <li>-->
<!--                        <a class="dropdown-item change-status" href="#"-->
<!--                           data-ticket-id="{{ ticket.id }}"-->
<!--                           data-new-status="{{ status.0 }}">-->
<!--                          {{ status.1 }}-->
<!--                        </a>-->
<!--                      </li>-->
<!--                    {% endif %}-->
<!--                  {% endfor %}-->
<!--                </ul>-->
              </div>

              <a href="{% url 'view_call_details' ticket.id %}"
                 class="text-white bg-blue-700 hover:bg-blue-800 focus:ring-1 focus:ring-blue-300 font-medium text-sm px-5 py-2.5 me-2 mb-2">
                Call Details
              </a>

              <a href="{% url 'view_ticket_notes' ticket.id %}"
                 class="text-white bg-blue-700 hover:bg-blue-800 focus:ring-1 focus:ring-blue-300 font-medium text-sm px-5 py-2.5 me-2 mb-2">
                From existing query
              </a>

                <a href="{% url 'view_ticket_notes_all' ticket.id %}"
                 class="text-white bg-blue-700 hover:bg-blue-800 focus:ring-1 focus:ring-blue-300 font-medium text-sm px-5 py-2.5 me-2 mb-2">
                all notes
              </a>
            </td>
          </tr>
          {% endif %}
        {% endfor %}
      </tbody>
    </table>
  </div>


<!-- Post-Call Details Modal (Bootstrap) -->
<div class="modal fade" id="postCallModal" tabindex="-1" role="dialog" aria-labelledby="postCallModalLabel" aria-hidden="true">
  <div class="modal-dialog" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="postCallModalLabel">Post-Call Details</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <form id="postCallForm" method="post">
        <div class="modal-body">
          {% csrf_token %}
          <input type="hidden" name="ticket_id" id="modal-ticket-id" value="">

          <div class="form-group">
            <label for="ticket-id">Ticket ID:</label>
            <input type="text" id="modal-ticket-id-display" class="form-control" readonly>
          </div>

          <div class="form-group">
            <label for="subject">Subject:</label>
            <input type="text" id="modal-subject" class="form-control" readonly>
          </div>

          <div class="form-group">
            <label for="status">Status:</label>
            <select id="modal-status" name="status" class="form-control">
              {% for status in ticket_statuses %}
                <option value="{{ status.0 }}">{{ status.1 }}</option>
              {% endfor %}
            </select>
          </div>



          <div class="form-group">
            <label for="call-note">Call Note:</label>
            <textarea name="note" id="modal-call-note" class="form-control" rows="4" placeholder="Describe the call..."></textarea>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
          <button type="submit" class="btn btn-primary">Save</button>
        </div>
      </form>
    </div>
  </div>
</div>




<!-- Client Call Modal with question: Is it a new query? -->
<div id="clientCallModal" class="hidden fixed inset-0 z-50 overflow-auto bg-black bg-opacity-50">
    <div class="relative p-8 bg-white w-full max-w-2xl mx-auto my-10 rounded-lg shadow-lg">
        <!-- Modal Header -->
        <div class="flex justify-between items-center border-b pb-4">
            <h5 class="text-xl font-semibold">Client Call</h5>
            <button type="button"
        onclick="closeModal()"
        class="text-gray-400 hover:text-gray-500 focus:outline-none">
    <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
    </svg>
</button>
        </div>

        <!-- Modal Body -->
        <div class="mt-6">
            <!-- Query Type Selection -->
            <div class="text-center mb-8">
                <h5 class="text-lg font-medium mb-4">Is it a new query?</h5>
                <div class="flex justify-center space-x-8">
                    <button type="button" class="query-option" onclick="showSection('new')">
    <div class="flex items-center space-x-2">
        <div class="w-6 h-6 rounded-full border-2 border-blue-500 flex items-center justify-center">
            <div class="query-circle w-4 h-4 rounded-full bg-transparent transition-colors duration-200"></div>
        </div>
        <span class="text-gray-700">New Query</span>
    </div>
</button>
<button type="button" class="query-option" onclick="showSection('existing')">
    <div class="flex items-center space-x-2">
        <div class="w-6 h-6 rounded-full border-2 border-blue-500 flex items-center justify-center">
            <div class="query-circle w-4 h-4 rounded-full bg-transparent transition-colors duration-200"></div>
        </div>
        <span class="text-gray-700">Existing Query</span>
    </div>
</button>
                </div>
            </div>

            <!-- Forms Container -->
            <div class="mt-6">

                <!-- New Query Form (Initially Hidden) -->
<div id="newQuerySection" class="query-section" style="display: none; margin-top: 20px;">
    <form id="newQueryForm" method="post" class="space-y-4">
        {% csrf_token %}
        <!-- Ticket Toggle -->
        <div class="mb-4">
            <div class="flex items-center justify-between">
                <label class="text-sm font-medium text-gray-700" for="create_ticket">
                    Need to create ticket?
                </label>
                <label class="relative inline-block w-14 h-7 cursor-pointer">
                    <input type="checkbox"
                           id="create_ticket"
                           name="create_ticket"
                           class="sr-only peer">
                    <div class="w-full h-full bg-gray-200 rounded-full peer-checked:bg-blue-600 transition-colors duration-200
                                after:content-[''] after:absolute after:top-0.5 after:left-0.5
                                after:bg-white after:rounded-full after:h-6 after:w-6
                                after:transition-transform peer-checked:after:translate-x-7"></div>
                </label>
            </div>
        </div>

        <!-- Primary Email -->
        <div class="mb-4">
            <label class="block text-sm font-medium text-gray-700 mb-1" for="primary_email">
                Primary Email (LEVELONE)
            </label>
            <input type="email"
                   id="primary_email"
                   name="primary_email"
                   value="levelone@example.com"
                   readonly
                   class="w-full px-3 py-2 bg-gray-50 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
        </div>

        <!-- Client Name -->
        <div class="mb-4">
            <label class="block text-sm font-medium text-gray-700 mb-1" for="client_name">
                Client Name
            </label>
            <input type="text"
                   id="client_name"
                   name="client_name"
                   required
                   placeholder="Enter client name"
                   class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
        </div>

        <!-- Email Fields (Hidden by default) -->
        <div id="emailFields" class="hidden space-y-4">
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1" for="client_email">
                    Client Email
                </label>
                <input type="email"
                       id="client_email"
                       name="client_email"
                       placeholder="Enter client email"
                       class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
            </div>
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1" for="cc_email">
                    CC
                </label>
                <input type="email"
                       id="cc_email"
                       name="cc_email"
                       placeholder="Enter CC email (optional)"
                       class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
            </div>
        </div>

        <!-- Note -->
        <div class="mb-4">
            <label class="block text-sm font-medium text-gray-700 mb-1" for="note">
                Note
            </label>
            <textarea id="note"
                      name="note"
                      rows="4"
                      required
                      placeholder="Enter note about the query"
                      class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500"></textarea>
        </div>

        <!-- Submit Button -->
        <button type="submit"
                id="newQuerySubmitBtn"
                class="w-full px-4 py-2 text-white bg-blue-600 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-colors">
            Save
        </button>
    </form>
</div>

                <!-- Existing Query Form (Initially Hidden) -->
<div id="existingQuerySection" class="query-section" style="display: none; margin-top: 20px;">
    <h5>Existing Query</h5>
    <form id="existingQueryForm" method="post" action="">
        {% csrf_token %}
<div class="mb-4">
    <label for="ticket-id" class="block text-sm font-medium text-gray-700 mb-1">
        Ticket ID
    </label>
    <div class="flex space-x-2">
        <input type="text"
               id="ticket-id"
               name="ticket_id"
               class="flex-1 px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500"
               placeholder="Enter ticket ID">
        <button type="button"
                id="search-ticket"
                class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
            Search
        </button>
    </div>
</div>

        <!-- Ticket details section (Initially hidden) -->
        <div id="ticket-details" style="display: none; margin-top: 20px;">
            <h5>Ticket Details</h5>
            <div class="mb-3">
                <label for="subject" class="form-label">Subject</label>
                <input type="text" class="form-control" id="subject" name="subject">
            </div>
            <div class="mb-3">
                <label for="assigned-to" class="form-label">Assigned To</label>
                <select class="form-control" id="assigned-to" name="assigned_to">
                    <!-- Dynamic options for users -->
                </select>
            </div>

            <div class="mb-3">
                <label for="priority" class="form-label">Priority</label>
                <select class="form-control" id="priority" name="priority">
                    <option value="low">Low</option>
                    <option value="medium">Medium</option>
                    <option value="high">High</option>
                    <option value="urgent">Urgent</option>
                </select>
            </div>

            <!-- Important: change the name to match 'client_call_note' -->
            <div class="mb-3">
                <label for="client_call_note" class="form-label">Note</label>
                <textarea class="form-control" id="client_call_note" name="client_call_note" rows="4" placeholder="Enter note about the ticket"></textarea>
            </div>

            <button type="submit" class="btn btn-success">Update Ticket</button>
        </div>
    </form>
</div>
            </div>
        </div>
    </div>
</div>


<!-- Call Details Table -->
<div class="relative max-w-full mx-auto bg-white p-6 shadow-lg rounded-lg overflow-x-auto my-2">
    <h4 class="text-xl font-semibold mb-4">Call Details</h4>
    <table class="w-full text-sm text-left rtl:text-right">
        <thead class="bg-gray-200 text-xs uppercase text-center">
            <tr>
                <th scope="col" class="px-6 py-3">
                    Client name
                </th>
                <th scope="col" class="px-6 py-3">
                    Client email
                </th>
                <th scope="col" class="px-6 py-3">
                    Call Duration
                </th>
                <th scope="col" class="px-6 py-3">
                    Ticket Created
                </th>
                <th scope="col" class="px-6 py-3">
                    Note
                </th>
            </tr>
        </thead>
        <tbody id="newQueriesBody">
            <!-- Dynamically populated content -->
        </tbody>
    </table>
</div>
</div>

<!-- Right Sidebar -->
<div class="fixed top-20 right-0 overflow-auto h-3/4 bg-white text-gray-700 transform translate-x-full hover:translate-x-0 transition-transform duration-300 z-40"
     id="rightSidebar">
    <div class="p-1">
        <div class="max-w-4xl mx-auto overflow-auto h-full rounded shadow-lg">
            <!-- Dashboard Card -->
            <div class="bg-white shadow-xl rounded-lg h-full">
                <!-- Chart and Stats Section -->
                <div class="grid grid-cols-1 md:grid-cols-1 gap-4 p-2">
                    <!-- Bar Chart Section -->
                    <div class="bg-gray-50 p-2 rounded-lg shadow-lg">
                        <h3 class="text-lg font-semibold mb-4">Today's Status</h3>
                        <canvas id="barChart"></canvas>
                    </div>

                    <!-- Summary Section -->
                    <div class="bg-gray-100 p-6">
                        <div class="flex justify-between items-center">
                            <div>
                                <span class="font-semibold text-gray-600">Total Tickets Today</span>
                                <p class="text-xl font-bold text-green-600">{{ todays_tickets }}</p>
                            </div>
                            <div>
                                <span class="font-semibold text-gray-600">Total Call Time</span>
                                <p class="text-xl font-bold text-blue-600">{{ call_duration }}</p>
                            </div>
                        </div>
                    </div>

                    <!-- Pie Chart Section -->
                    <div class="bg-gray-50 p-2 rounded-lg shadow-lg">
                        <h3 class="text-lg font-semibold mb-4">Overall Tickets</h3>
                        <canvas id="pieChart"></canvas>
                    </div>

                    <table class="w-full border-collapse border border-gray-300 text-left">
                        <tbody id="dataTable" class="bg-white"></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
</div>


</div>
</div>




<!-- Bootstrap JS (including Popper.js) -->
    <!-- Include Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <!-- Include Bootstrap and jQuery in your template -->


    <script>

            document.querySelectorAll('.btn-close-ticket').forEach(button => {
            button.addEventListener('click', function() {
                const ticketId = this.dataset.ticketId;
                if (confirm('Are you sure you want to close this ticket?')) {
                    // Create a form to submit the POST request
                    const form = document.createElement('form');
                    form.method = 'POST';
                    form.action = `/tickets/close/${ticketId}/`;  // Adjust URL as per your setup
                    const csrfInput = document.createElement('input');
                    csrfInput.type = 'hidden';
                    csrfInput.name = 'csrfmiddlewaretoken';
                    csrfInput.value = '{{ csrf_token }}';  // Ensure you have CSRF token in your template context

                    form.appendChild(csrfInput);
                    document.body.appendChild(form);
                    form.submit();
                }
            });
        });

            // Add click event for custom dropdown toggle
            document.getElementById('activityDropdown').addEventListener('click', function() {
                this.classList.toggle('active');
            });

             document.addEventListener("DOMContentLoaded", function() {
            // Get all buttons that toggle ticket options
            const ticketToggles = document.querySelectorAll('.ticket-toggle');

            ticketToggles.forEach(button => {
                button.addEventListener('click', function() {
                    const currentTarget = this.getAttribute('data-bs-target');

                    // Collapse all other ticket options
                    ticketToggles.forEach(btn => {
                        const target = btn.getAttribute('data-bs-target');
                        if (target !== currentTarget) {
                            const collapseElement = document.querySelector(target);
                            if (collapseElement && collapseElement.classList.contains('show')) {
                                // Collapse if it's not the current target
                                collapseElement.classList.remove('show');
                            }
                        }
                    });
                });
            });
        });
        </script>

    {% if error %}
        <script>
            Swal.fire({
                title: 'Unauthorized Access',
                text: "{{ error }}",
                icon: 'error',
                confirmButtonText: 'Okay'
            }).then((result) => {
                if (result.isConfirmed) {
                    window.location.href = "{% url 'home' %}";  // Redirect to the homepage
                }
            });
        </script>
        {% endif %}


<script>
document.addEventListener('DOMContentLoaded', function () {
    // Get CSRF token from the page
    const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;

    // Function to initialize ticket statuses from localStorage
    function initializeTicketStatuses() {
        document.querySelectorAll('[data-ticket-id]').forEach(row => {
            const ticketId = row.dataset.ticketId;
            const statusChanged = localStorage.getItem(`ticket_${ticketId}_status_changed`);
            if (statusChanged) {
                const individualTimeCell = row.querySelector('.time-column.individual-time');
                if (individualTimeCell) {
                    individualTimeCell.classList.remove('exceeded');
                }
                row.dataset.statusChanged = statusChanged;
            }
        });
    }

    // Initialize ticket statuses when page loads
    initializeTicketStatuses();

    // Listen for clicks on all status change links in the dashboard
    document.querySelectorAll('.change-status').forEach(button => {
        button.addEventListener('click', function (e) {
            e.preventDefault();

            const ticketId = this.dataset.ticketId;
            const newStatus = this.dataset.newStatus;
            const ticketRow = document.querySelector(`tr[data-ticket-id="${ticketId}"]`);

            // Perform AJAX request to update the status
            fetch('/update_ticket_status/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken
                },
                body: JSON.stringify({
                    ticket_id: ticketId,
                    new_status: newStatus
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Find and update the status cell in the current row
                    const statusCell = ticketRow.querySelector('td:nth-child(3)');
                    if (statusCell) {
                        statusCell.textContent = data.new_status_label;
                    }

                    // Store the status change timestamp in localStorage and row dataset
                    const statusChangeTime = data.status_changed || new Date().toISOString();
                    localStorage.setItem(`ticket_${ticketId}_status_changed`, statusChangeTime);
                    ticketRow.dataset.statusChanged = statusChangeTime;

                    // Reset individual time column color
                    const individualTimeCell = ticketRow.querySelector('.time-column.individual-time');
                    if (individualTimeCell) {
                        individualTimeCell.classList.remove('exceeded');
                        individualTimeCell.style.animation = 'none';
                        individualTimeCell.style.backgroundColor = '';
                        void individualTimeCell.offsetWidth;
                        individualTimeCell.style.animation = '';
                    }

                    // Update the individual timer display to show 0
                    const individualTimerSpan = ticketRow.querySelector('#individual-timer-' + ticketId);
                    if (individualTimerSpan) {
                        individualTimerSpan.textContent = '0:00:00';
                    }

                    // If the status is 'closed' or 'resolved', hide the row
                    if (newStatus === 'closed' || newStatus === 'resolved') {
                        ticketRow.style.display = 'none';
                        const optionsRow = document.querySelector(`#options-${ticketId}`).parentNode;
                        if (optionsRow) {
                            optionsRow.style.display = 'none';
                        }
                    }

                    // Keep the total time column colored if time limit is exceeded
                    if (ticketRow.classList.contains('priority-alert')) {
                        const totalTimeCell = ticketRow.querySelector('.time-column.total-time');
                        if (totalTimeCell) {
                            const priorityClass = `priority-${ticketRow.dataset.priority}`;
                            totalTimeCell.classList.add(priorityClass);
                        }
                    }

                    // Show success message
                    Swal.fire({
                        title: 'Success!',
                        text: 'Ticket status updated successfully',
                        icon: 'success',
                        timer: 2000,
                        showConfirmButton: false
                    });
                } else {
                    // Show error message
                    Swal.fire({
                        title: 'Error!',
                        text: data.message || 'Failed to update status',
                        icon: 'error'
                    });
                }
            })
            .catch(error => {
                console.error('Error:', error);
                Swal.fire({
                    title: 'Error!',
                    text: 'An error occurred while updating the status',
                    icon: 'error'
                });
            });
        });
    });

    // Function to update time display and colors
        function updateTicketDisplay(ticketId) {
        const ticketRow = document.querySelector(`tr[data-ticket-id="${ticketId}"]`);
        if (!ticketRow) return;

        const totalTimeCell = ticketRow.querySelector('.time-column.total-time');
        const individualTimeCell = ticketRow.querySelector('.time-column.individual-time');
        const statusChanged = localStorage.getItem(`ticket_${ticketId}_status_changed`);

        if (ticketRow.classList.contains('priority-alert')) {
            const priorityClass = `priority-${ticketRow.dataset.priority}`;

            // Always keep total time column colored if time limit is exceeded
            if (totalTimeCell) {
                totalTimeCell.classList.add(priorityClass);
            }

            // Only add color to individual time if status hasn't been changed
            if (individualTimeCell && !statusChanged) {
                individualTimeCell.classList.add('exceeded');
            }
        }
    }

    // Update displays initially
    document.querySelectorAll('[data-ticket-id]').forEach(row => {
        updateTicketDisplay(row.dataset.ticketId);
    });

    // Update displays periodically
    setInterval(() => {
        document.querySelectorAll('[data-ticket-id]').forEach(row => {
            updateTicketDisplay(row.dataset.ticketId);
        });
    }, 30000); // Update every 30 seconds

    // Clear old status changes from localStorage periodically
    function cleanupOldStatusChanges() {
        const keys = Object.keys(localStorage);
        const now = new Date();
        keys.forEach(key => {
            if (key.startsWith('ticket_') && key.endsWith('_status_changed')) {
                const timestamp = localStorage.getItem(key);
                const changeTime = new Date(timestamp);
                // Remove entries older than 24 hours
                if (now - changeTime > 24 * 60 * 60 * 1000) {
                    localStorage.removeItem(key);
                }
            }
        });
    }

    // Run cleanup every hour
    setInterval(cleanupOldStatusChanges, 60 * 60 * 1000);
    cleanupOldStatusChanges(); // Run cleanup on page load

    // Close any dropdowns when clicking outside
    document.addEventListener('click', function(e) {
        if (!e.target.matches('.dropdown-toggle')) {
            document.querySelectorAll('.dropdown-menu').forEach(dropdown => {
                if (dropdown.classList.contains('show')) {
                    dropdown.classList.remove('show');
                }
            });
        }
    });
});
</script>

<script>
document.addEventListener('DOMContentLoaded', function () {
    const postCallForm = document.querySelector('form');

    if (postCallForm) {
        postCallForm.addEventListener('submit', function (e) {
            e.preventDefault(); // Prevent the form from submitting normally

            const formData = new FormData(this);
            const actionUrl = this.getAttribute('action');

            fetch(actionUrl, {
                method: 'POST',
                body: formData,
                headers: {
                    'X-CSRFToken': formData.get('csrfmiddlewaretoken')
                }
            })
            .then(response => {
                if (response.ok) {
                    // After successful form submission, redirect or update UI
                    window.location.href = '/dashboard/';  // Redirect to dashboard
                } else {
                    console.error('Error saving post-call details.');
                }
            })
            .catch(error => {
                console.error('Error:', error);
            });
        });
    }
});

</script>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // Initialize variables and constants
    let timers = {};
    const localStorageKey = 'ticketTimers';
    const breakToggle = document.getElementById('breakToggle');
    const breakStatus = document.getElementById('breakStatus');
    const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;
    let activeTicketId = null;
    let activeCallTicketId = null;

    // Add CSS for disabled button styling
    const style = document.createElement('style');
    style.textContent = `
        .start-button.started-by-call {
            opacity: 0.7;
            cursor: not-allowed !important;
            background-color: #6c757d !important;
            border-color: #6c757d !important;
            pointer-events: all !important;
        }
        .start-button.blocked {
            opacity: 0.7;
            cursor: not-allowed !important;
            background-color: #6c757d !important;
            border-color: #6c757d !important;
            pointer-events: all !important;
        }
        .call-action-form button.blocked {
            opacity: 0.7;
            cursor: not-allowed !important;
            pointer-events: all !important;
        }
        /* Hover states */
        .start-button.blocked:hover,
        .start-button.started-by-call:hover,
        .call-action-form button.blocked:hover {
            opacity: 0.7 !important;
            cursor: not-allowed !important;
            background-color: #6c757d !important;
            border-color: #6c757d !important;
        }
    `;
    document.head.appendChild(style);


    // Utility functions
    function formatTime(seconds) {
        const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
        const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
        const s = Math.floor(seconds % 60).toString().padStart(2, '0');
        return `${h}:${m}:${s}`;
    }

    function getCurrentDateTime() {
        const now = new Date();
        return now.getUTCFullYear() + '-' +
               String(now.getUTCMonth() + 1).padStart(2, '0') + '-' +
               String(now.getUTCDate()).padStart(2, '0') + ' ' +
               String(now.getUTCHours()).padStart(2, '0') + ':' +
               String(now.getUTCMinutes()).padStart(2, '0') + ':' +
               String(now.getUTCSeconds()).padStart(2, '0');
    }

    function blockOtherTicketButtons(currentTicketId) {
    document.querySelectorAll('.start-button').forEach(button => {
        const ticketId = button.dataset.ticketId;
        if (ticketId !== currentTicketId) {
            button.classList.add('blocked');
            button.disabled = true;
        }
    });
}

    function unblockAllTicketButtons() {
        document.querySelectorAll('.start-button').forEach(button => {
            button.classList.remove('blocked');
            button.disabled = false;
        });
    }

    function blockAllTicketInteractions(exceptTicketId) {
        document.querySelectorAll('.start-button, .call-action-form button').forEach(button => {
            const ticketId = button.closest('[data-ticket-id]')?.dataset.ticketId;
            if (ticketId !== exceptTicketId) {
                button.classList.add('blocked');
                button.disabled = true;
            }
        });
    }

    function unblockAllTicketInteractions() {
        document.querySelectorAll('.start-button, .call-action-form button').forEach(button => {
            button.classList.remove('blocked');
            button.disabled = false;
        });
        // Reapply blocks if there's an active timer
        if (activeTicketId && !activeCallTicketId) {
            blockOtherTicketButtons(activeTicketId);
        }
    }

    function pauseFrontendTimer(ticketId) {
        if (timers[ticketId] && timers[ticketId].interval) {
            clearInterval(timers[ticketId].interval);

            timers[ticketId].isPausedByCall = true;
            timers[ticketId].pausedAt = {
                total: timers[ticketId].currentTotal,
                individual: timers[ticketId].currentIndividual,
                time: Date.now(),
                pausedDateTime: getCurrentDateTime()
            };

            const totalTimerElement = document.getElementById('timer-' + ticketId);
            const individualTimerElement = document.getElementById('individual-timer-' + ticketId);

            if (totalTimerElement) {
                totalTimerElement.textContent = formatTime(timers[ticketId].currentTotal);
            }
            if (individualTimerElement) {
                individualTimerElement.textContent = formatTime(timers[ticketId].currentIndividual);
            }

            localStorage.setItem(localStorageKey, JSON.stringify(timers));
        }
    }

    function resumeFrontendTimer(ticketId) {
        if (timers[ticketId] && timers[ticketId].isPausedByCall) {
            const pausedValues = timers[ticketId].pausedAt;
            if (pausedValues) {
                startFrontendTimers(
                    ticketId,
                    pausedValues.total,
                    pausedValues.individual,
                    Date.now(),
                    timers[ticketId].startedByCall // Preserve the startedByCall state
                );
                delete timers[ticketId].isPausedByCall;
                delete timers[ticketId].pausedAt;
            }
        }
    }

    function startFrontendTimers(ticketId, totalAccumulatedTime, individualAccumulatedTime, startTime, startedByCall = false) {
        const totalTimerElement = document.getElementById('timer-' + ticketId);
        const individualTimerElement = document.getElementById('individual-timer-' + ticketId);
        const startButton = document.querySelector(`.start-button[data-ticket-id="${ticketId}"]`);

        if (!totalTimerElement || !individualTimerElement) return;

        if (timers[ticketId] && timers[ticketId].interval) {
            clearInterval(timers[ticketId].interval);
        }

        // Update button state for call-started timers
        if (startButton && startedByCall) {
            startButton.textContent = 'Stop';
            startButton.classList.add('started-by-call');
            startButton.disabled = true;
        }

        timers[ticketId] = {
            totalAccumulatedTime: totalAccumulatedTime,
            individualAccumulatedTime: individualAccumulatedTime,
            startTime: startTime,
            isActive: true,
            currentTotal: totalAccumulatedTime,
            currentIndividual: individualAccumulatedTime,
            startDateTime: getCurrentDateTime(),
            startedByCall: startedByCall // Track if timer was started by call
        };

        totalTimerElement.textContent = formatTime(totalAccumulatedTime);
        individualTimerElement.textContent = formatTime(individualAccumulatedTime);

        timers[ticketId].interval = setInterval(() => {
            const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
            const totalTime = totalAccumulatedTime + elapsedTime;
            const individualTime = individualAccumulatedTime + elapsedTime;

            timers[ticketId].currentTotal = totalTime;
            timers[ticketId].currentIndividual = individualTime;

            totalTimerElement.textContent = formatTime(totalTime);
            individualTimerElement.textContent = formatTime(individualTime);
        }, 1000);

        if (timers[ticketId].isPausedByCall) {
            delete timers[ticketId].isPausedByCall;
        }

        localStorage.setItem(localStorageKey, JSON.stringify(timers));
    }

    function stopFrontendTimers(ticketId) {
        if (timers[ticketId] && timers[ticketId].interval) {
            clearInterval(timers[ticketId].interval);

            timers[ticketId].totalAccumulatedTime = timers[ticketId].currentTotal;
            timers[ticketId].individualAccumulatedTime = timers[ticketId].currentIndividual;
            timers[ticketId].isActive = false;
            timers[ticketId].stopDateTime = getCurrentDateTime();

            const totalTimerElement = document.getElementById('timer-' + ticketId);
            const individualTimerElement = document.getElementById('individual-timer-' + ticketId);
            const startButton = document.querySelector(`.start-button[data-ticket-id="${ticketId}"]`);

            if (totalTimerElement) {
                totalTimerElement.textContent = formatTime(timers[ticketId].totalAccumulatedTime);
            }
            if (individualTimerElement) {
                individualTimerElement.textContent = formatTime(timers[ticketId].individualAccumulatedTime);
            }

            // Reset button state if it was started by call
            if (startButton && timers[ticketId].startedByCall) {
                startButton.classList.remove('started-by-call');
                startButton.disabled = false;
            }

            delete timers[ticketId];
            localStorage.setItem(localStorageKey, JSON.stringify(timers));
        }
    }

    function handleBreakToggle(isBreak) {
        // First make the server request to check if break is allowed
        fetch("{% url 'toggle_break_status' %}", {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({})
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'error') {
                // Revert the checkbox if there's an error
                breakToggle.checked = !isBreak;

                // Show error message using SweetAlert2
                Swal.fire({
                    title: 'Break Not Available',
                    text: data.message,
                    icon: 'warning',
                    confirmButtonText: 'Ok',
                    confirmButtonColor: '#3085d6'
                });
                return;
            }

            // If successful, proceed with existing break toggle logic
            // Update text and classes
            const breakStatus = document.getElementById('breakStatus');
            breakStatus.textContent = isBreak ? 'On Break' : 'Active';

            // Remove existing classes and add the appropriate one
            breakStatus.classList.remove('active', 'break');
            breakStatus.classList.add(isBreak ? 'break' : 'active');

            // Update the toggle color
            const modernSlider = document.querySelector('.modern-slider');
            if (modernSlider) {
                modernSlider.style.backgroundColor = isBreak ? '#dc3545' : '#28a745';
            }

            // Handle all active timers
            document.querySelectorAll('.start-button').forEach(button => {
                const ticketId = button.dataset.ticketId;

                if (isBreak && timers[ticketId] && timers[ticketId].isActive) {
                    clearInterval(timers[ticketId].interval);
                    timers[ticketId].isPausedForBreak = true;
                    timers[ticketId].pausedAt = {
                        total: timers[ticketId].currentTotal,
                        individual: timers[ticketId].currentIndividual,
                        time: Date.now(),
                        pausedDateTime: getCurrentDateTime()
                    };

                    const totalTimerElement = document.getElementById('timer-' + ticketId);
                    const individualTimerElement = document.getElementById('individual-timer-' + ticketId);

                    if (totalTimerElement) {
                        totalTimerElement.textContent = formatTime(timers[ticketId].currentTotal);
                    }
                    if (individualTimerElement) {
                        individualTimerElement.textContent = formatTime(timers[ticketId].currentIndividual);
                    }
                } else if (!isBreak && timers[ticketId] && timers[ticketId].isPausedForBreak) {
                    const pausedValues = timers[ticketId].pausedAt;
                    if (pausedValues) {
                        startFrontendTimers(
                            ticketId,
                            pausedValues.total,
                            pausedValues.individual,
                            Date.now(),
                            timers[ticketId].startedByCall
                        );
                        timers[ticketId].isPausedForBreak = false;
                        delete timers[ticketId].pausedAt;
                    }
                }
            });

            // Show notification if others can take breaks
            if (data.message) {
                Swal.fire({
                    title: 'Break Available',
                    text: data.message,
                    icon: 'info',
                    confirmButtonText: 'Ok',
                    confirmButtonColor: '#3085d6'
                });
            }
        })
        .catch(error => {
            console.error('Error:', error);
            // Revert the checkbox state on error
            breakToggle.checked = !isBreak;
        });
    }

    // Call Action Form Handler
    document.querySelectorAll('.call-action-form').forEach(function(form) {
        form.addEventListener('submit', function(e) {
            e.preventDefault();

            const formData = new FormData(this);
            const actionUrl = this.getAttribute('action');
            const ticketId = this.dataset.ticketId;

            fetch(actionUrl, {
                method: 'POST',
                body: formData,
                headers: {
                    'X-CSRFToken': formData.get('csrfmiddlewaretoken'),
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    if (formData.get('action') === 'start_call') {
                        // Store whether the timer was started by this call
                        form.dataset.timerStartedByCall = data.timer_started_by_call;
                        activeCallTicketId = ticketId;
                        blockAllTicketInteractions(ticketId);

                        // Get the start button and handle timer
                        const startButton = document.querySelector(`.start-button[data-ticket-id="${ticketId}"]`);
                        if (startButton && data.timer_started_by_call) {
                            // Get the timer elements
                            const totalTimerElement = document.getElementById('timer-' + ticketId);
                            const individualTimerElement = document.getElementById('individual-timer-' + ticketId);

                            // Parse current display values if they exist
                            let totalTime = 0;
                            let individualTime = 0;

                            if (totalTimerElement && individualTimerElement) {
                                // Convert HH:MM:SS to seconds
                                const parseTimeToSeconds = (timeStr) => {
                                    const [hours, minutes, seconds] = timeStr.split(':').map(Number);
                                    return hours * 3600 + minutes * 60 + seconds;
                                };

                                // Get current display values
                                totalTime = parseTimeToSeconds(totalTimerElement.textContent);
                                individualTime = parseTimeToSeconds(individualTimerElement.textContent);
                            }

                            // Check for existing timer in memory
                            if (timers[ticketId]) {
                                totalTime = Math.max(totalTime, timers[ticketId].currentTotal || 0);
                                individualTime = Math.max(individualTime, timers[ticketId].currentIndividual || 0);
                            } else {
                                // Check localStorage for existing timer
                                const savedTimers = JSON.parse(localStorage.getItem(localStorageKey) || '{}');
                                if (savedTimers[ticketId]) {
                                    totalTime = Math.max(totalTime, savedTimers[ticketId].currentTotal || 0);
                                    individualTime = Math.max(individualTime, savedTimers[ticketId].currentIndividual || 0);
                                }
                            }

                            // Use server values as fallback
                            totalTime = Math.max(totalTime, data.time_spent_seconds || 0);
                            individualTime = Math.max(individualTime, data.individual_time_spent_seconds || 0);

                            // Start timer with preserved values
                            startFrontendTimers(
                                ticketId,
                                totalTime,
                                individualTime,
                                Date.now(),
                                true // Indicate this timer was started by call
                            );
                            startButton.textContent = 'Stop';
                        }

                        // Update UI and pause timers for paused tickets
                        if (data.paused_tickets) {
                            data.paused_tickets.forEach(pausedId => {
                                const pausedButton = document.querySelector(`.start-button[data-ticket-id="${pausedId}"]`);
                                if (pausedButton) {
                                    pausedButton.textContent = 'Paused';
                                    pausedButton.classList.add('paused-by-call');
                                    pauseFrontendTimer(pausedId);
                                }
                            });
                        }

                        // Update call button
                        const button = this.querySelector('button');
                        button.textContent = 'End Call';
                        button.classList.remove('btn-warning');
                        button.classList.add('btn-danger');
                        this.querySelector('input[name="action"]').value = 'end_call';
                    } else if (formData.get('action') === 'end_call') {
                        // Show the post-call modal
                        $('#postCallModal').modal('show');

                        // Populate modal fields
                        document.getElementById('modal-ticket-id').value = data.ticket_id;
                        document.getElementById('modal-ticket-id-display').value = data.ticket_display_id;
                        document.getElementById('modal-subject').value = data.subject;
                        document.getElementById('modal-status').value = data.current_status;
                    }
                }
            })
            .catch(error => console.error('Error:', error));
        });
    });

    // Post Call Form Handler
    document.getElementById('postCallForm').addEventListener('submit', function (e) {
        e.preventDefault();

        const formData = new FormData(this);
        const ticketId = document.getElementById('modal-ticket-id').value;

        if (ticketId) {
            fetch(`/ticket/post_call_details/${ticketId}/`, {
                method: 'POST',
                body: formData,
                headers: {
                    'X-CSRFToken': formData.get('csrfmiddlewaretoken'),
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    activeCallTicketId = null;
                    unblockAllTicketInteractions();
                    // Resume paused timers
                    if (data.resumed_tickets) {
                        data.resumed_tickets.forEach(resumedId => {
                            const resumedButton = document.querySelector(`.start-button[data-ticket-id="${resumedId}"]`);
                            if (resumedButton) {
                                resumedButton.textContent = 'Stop';
                                resumedButton.classList.remove('paused-by-call');
                                resumeFrontendTimer(resumedId);
                            }
                        });
                    }

                    // Find the call form to check if timer should be stopped
                    const callForm = document.querySelector(`.call-action-form[data-ticket-id="${ticketId}"]`);
                    const timerStartedByCall = callForm ? callForm.dataset.timerStartedByCall === 'true' : false;

                    // Handle the timer that was started by the call
                    if (timerStartedByCall) {
                        const startButton = document.querySelector(`.start-button[data-ticket-id="${ticketId}"]`);
                        if (startButton) {
                            startButton.textContent = 'Start';
                            startButton.classList.remove('started-by-call');
                            startButton.disabled = false;
                            stopFrontendTimers(ticketId);
                        }
                    }

                    // Reset call button state
                    if (callForm) {
                        const callButton = callForm.querySelector('button');
                        callButton.textContent = 'Start Call';
                        callButton.classList.remove('btn-danger');
                        callButton.classList.add('btn-warning');
                        callForm.querySelector('input[name="action"]').value = 'start_call';
                        callForm.dataset.timerStartedByCall = 'false';
                    }

                    // Close modal and reload
                    $('#postCallModal').modal('hide');
                    location.reload();
                }
            })
            .catch(error => console.error('Error:', error));
        }
    });

    // Modal close handlers
    const closeButton = document.querySelector('#postCallModal .btn-secondary');
    const closeIcon = document.querySelector('#postCallModal .close');

    if (closeButton) {
        closeButton.addEventListener('click', function() {
            $('#postCallModal').modal('hide');
        });
    }

    if (closeIcon) {
        closeIcon.addEventListener('click', function() {
            $('#postCallModal').modal('hide');
        });
    }

    // Enhanced Start/Stop button click handler with call-started timer blocking
    document.querySelectorAll('.start-button').forEach(button => {
        button.addEventListener('click', function(e) {
            e.preventDefault();

            if (breakToggle.checked) return;

            const ticketId = this.dataset.ticketId;

            // Block interaction if timer was started by call
            if (timers[ticketId] && timers[ticketId].startedByCall) {
                alert('This timer was started by a call and can only be stopped by ending the call.');
                return;
            }

            // Block if there's an active call on another ticket
            if (activeCallTicketId && activeCallTicketId !== ticketId) {
                alert('Please end the current call before starting a new timer.');
                return;
            }

            const action = this.textContent.trim() === 'Start' ? 'start' : 'stop';

            fetch(`/tickets/${ticketId}/${action}/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken,
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    this.textContent = action === 'start' ? 'Stop' : 'Start';

                    if (action === 'start') {
                        activeTicketId = ticketId;
                        blockOtherTicketButtons(ticketId);
                        startFrontendTimers(
                            ticketId,
                            data.time_spent_seconds,
                            data.individual_time_spent_seconds,
                            Date.now(),
                            false
                        );
                    } else {
                        activeTicketId = null;
                        unblockAllTicketButtons();
                        stopFrontendTimers(ticketId);
                    }
                } else {
                    alert('Failed to update ticket activity');
                }
            })
            .catch(error => console.error('Error:', error));
        });
    });

    // Break toggle event listener
    if (breakToggle) {
        breakToggle.addEventListener('change', function() {
            handleBreakToggle(this.checked);
        });
    }

    // Initialize active timers from localStorage with call-started state preservation
    const savedTimers = JSON.parse(localStorage.getItem(localStorageKey) || '{}');
    Object.entries(savedTimers).forEach(([ticketId, timerData]) => {
        if (timerData.isActive) {
            startFrontendTimers(
                ticketId,
                timerData.totalAccumulatedTime,
                timerData.individualAccumulatedTime,
                timerData.startTime,
                timerData.startedByCall // Preserve the call-started state
            );
        }
    });
});
</script>

<script>
document.addEventListener('DOMContentLoaded', function () {
    // Handle Note form submission via AJAX
    document.getElementById('noteForm').addEventListener('submit', function(e) {
        e.preventDefault();  // Prevent default form submission

        const formData = new FormData(this);

        fetch('{% url "save_call_note" %}', {
            method: 'POST',
            body: formData,
            headers: {
                'X-CSRFToken': formData.get('csrfmiddlewaretoken'),
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                alert(data.message);  // Show success message
                $('#clientCallModal').modal('hide');  // Close modal
            } else {
                alert(data.message);  // Show error message
            }
        })
        .catch(error => console.error('Error:', error));
    });
});
</script>

<script>
// Global variables
let callStartTime = null;
const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;

// Modal Control Functions
function openModal() {
    const modal = document.getElementById('clientCallModal');
    if (modal) {
        modal.classList.remove('hidden');
        document.body.style.overflow = 'hidden';
        startNewCall();
    }
}

function closeModal() {
    const modal = document.getElementById('clientCallModal');
    if (modal) {
        modal.classList.add('hidden');
        document.body.style.overflow = 'auto';
        const newQuerySection = document.getElementById('newQuerySection');
        const existingQuerySection = document.getElementById('existingQuerySection');
        if (newQuerySection) newQuerySection.style.display = 'none';
        if (existingQuerySection) existingQuerySection.style.display = 'none';

        // Reset circles
        document.querySelectorAll('.query-circle').forEach(circle => {
            circle.classList.remove('bg-blue-500');
        });

        endNewCall();
    }
}

function showSection(type) {
    const newQuerySection = document.getElementById('newQuerySection');
    const existingQuerySection = document.getElementById('existingQuerySection');

    // Reset all circles
    document.querySelectorAll('.query-circle').forEach(circle => {
        circle.classList.remove('bg-blue-500');
    });

    // Get clicked button's circle and activate it
    const clickedButton = event.currentTarget;
    const circle = clickedButton.querySelector('.query-circle');
    circle.classList.add('bg-blue-500');

    // Show/hide sections
    if (newQuerySection) newQuerySection.style.display = type === 'new' ? 'block' : 'none';
    if (existingQuerySection) existingQuerySection.style.display = type === 'existing' ? 'block' : 'none';
}

// Timer Functions
function startNewCall() {
    fetch('/start-new-call/', {
        method: 'POST',
        headers: {
            'X-CSRFToken': csrfToken,
            'Content-Type': 'application/json'
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            callStartTime = new Date(data.call_start_time);
            console.log('Call started successfully');
        }
    })
    .catch(error => console.error('Error starting call:', error));
}

function endNewCall() {
    if (!callStartTime) return;

    fetch('/end-new-call/', {
        method: 'POST',
        headers: {
            'X-CSRFToken': csrfToken,
            'Content-Type': 'application/json'
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            callStartTime = null;
            console.log('Call ended successfully');
        }
    })
    .catch(error => console.error('Error ending call:', error));
}

// Table Functions
function loadCallQueries() {
    fetch('/get-call-queries/')
        .then(response => response.json())
        .then(data => {
            const tbody = document.getElementById('newQueriesBody');
            tbody.innerHTML = '';

            data.new_queries.forEach(query => {
                const row = document.createElement('tr');
                row.className = "border-b border-gray-200 hover:bg-gray-100";
                row.innerHTML = `
                    <th scope="row" class="px-6 py-4 font-medium whitespace-nowrap">
                        ${query.client_name}
                    </th>
                    <td class="px-6 py-4">
                        ${query.client_email || '-'}
                    </td>
                    <td class="px-6 py-4">
                        ${query.call_duration || '-'}
                    </td>
                    <td class="px-6 py-4 text-center">
                        ${query.ticket_created ? '✅' : '❌'}
                    </td>
                    <td class="px-6 py-4">
                        ${query.note}
                    </td>
                `;
                tbody.appendChild(row);
            });
        })
        .catch(error => console.error('Error loading queries:', error));
}

// Main initialization
document.addEventListener('DOMContentLoaded', function() {
    // Initialize elements
    const modal = document.getElementById('clientCallModal');
    const createTicketToggle = document.getElementById('create_ticket');
    const emailFields = document.getElementById('emailFields');
    const searchButton = document.getElementById('search-ticket');

    // Modal event listeners
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') closeModal();
    });

    if (modal) {
        modal.addEventListener('click', function(e) {
            if (e.target === this) closeModal();
        });
    }

    // Create ticket toggle handler
    if (createTicketToggle) {
        createTicketToggle.addEventListener('change', function() {
            // Update the submit button
            const submitBtn = document.getElementById('newQuerySubmitBtn');
            if (submitBtn) {
                submitBtn.textContent = this.checked ? 'Send' : 'Save';
                // Update button colors
                if (this.checked) {
                    submitBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                    submitBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                } else {
                    submitBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                    submitBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');
                }
            }

            // Toggle email fields
            if (emailFields) {
                if (this.checked) {
                    emailFields.classList.remove('hidden');
                    const clientEmailInput = document.getElementById('client_email');
                    if (clientEmailInput) {
                        clientEmailInput.required = true;
                    }
                } else {
                    emailFields.classList.add('hidden');
                    const clientEmailInput = document.getElementById('client_email');
                    if (clientEmailInput) {
                        clientEmailInput.required = false;
                        clientEmailInput.value = '';
                        document.getElementById('cc_email').value = '';
                    }
                }
            }

            // Log state for debugging
            console.log('Toggle state:', this.checked);
            console.log('Email fields visibility:', !emailFields.classList.contains('hidden'));
        });
    }

    // Search ticket handler
    if (searchButton) {
        searchButton.addEventListener('click', function() {
            const ticketId = document.getElementById('ticket-id').value;
            if (!ticketId) {
                alert('Please enter a ticket ID');
                return;
            }

            // Show loading state
            this.disabled = true;
            this.innerHTML = `
                <svg class="animate-spin h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>`;

            fetch(`/tickets/search/${ticketId}/`, {
                method: 'GET',
                headers: { 'X-CSRFToken': csrfToken }
            })
            .then(response => response.json())
            .then(data => {
                this.disabled = false;
                this.textContent = 'Search';

                const ticketDetails = document.getElementById('ticket-details');
                if (data.success) {
                    ticketDetails.style.display = 'block';
                    document.getElementById('subject').value = data.ticket.subject;
                    document.getElementById('priority').value = data.ticket.priority;

                    const assignedToDropdown = document.getElementById('assigned-to');
                    assignedToDropdown.innerHTML = '';
                    data.users.forEach(user => {
                        const option = document.createElement('option');
                        option.value = user.id;
                        option.textContent = user.username;
                        option.selected = user.id == data.ticket.assigned_to;
                        assignedToDropdown.appendChild(option);
                    });

                    document.getElementById('client_call_note').value = data.ticket.note || '';
                } else {
                    alert('Ticket not found');
                    ticketDetails.style.display = 'none';
                }
            })
            .catch(error => {
                console.error('Error:', error);
                this.disabled = false;
                this.textContent = 'Search';
                alert('Error searching for ticket');
            });
        });
    }

    // Form submission handlers
    document.getElementById('newQueryForm')?.addEventListener('submit', async function(e) {
        e.preventDefault();

        try {
            const endCallResponse = await fetch('/end-new-call/', {
                method: 'POST',
                headers: {
                    'X-CSRFToken': csrfToken,
                    'Content-Type': 'application/json'
                }
            }).then(response => response.json());

            if (endCallResponse.status === 'success') {
                const formData = new FormData(this);
                if (endCallResponse.call_duration) {
                    formData.append('call_duration_seconds', endCallResponse.call_duration);
                }

                const saveResponse = await fetch('/save-new-call-query/', {
                    method: 'POST',
                    headers: { 'X-CSRFToken': csrfToken },
                    body: formData
                }).then(response => response.json());

                if (saveResponse.status === 'success') {
                    alert('Call query saved successfully');
                    closeModal();
                    loadCallQueries();
                    window.location.reload();
                } else {
                    throw new Error('Failed to save call query');
                }
            }
        } catch (error) {
            console.error('Error:', error);
            alert('Error saving call query');
        }
    });

    document.getElementById('existingQueryForm')?.addEventListener('submit', async function(e) {
        e.preventDefault();

        try {
            const endCallResponse = await fetch('/end-new-call/', {
                method: 'POST',
                headers: {
                    'X-CSRFToken': csrfToken,
                    'Content-Type': 'application/json'
                }
            }).then(response => response.json());

            const formData = new FormData(this);
            if (endCallResponse.status === 'success' && endCallResponse.call_duration) {
                formData.append('call_duration_seconds', endCallResponse.call_duration);
            }

            const ticketId = document.getElementById('ticket-id').value;
            const updateResponse = await fetch(`/tickets/update/${ticketId}/`, {
                method: 'POST',
                headers: { 'X-CSRFToken': csrfToken },
                body: formData
            }).then(response => response.json());

            if (updateResponse.success) {
                alert('Ticket updated successfully');
                closeModal();
                window.location.reload();
            } else {
                throw new Error('Failed to update ticket');
            }
        } catch (error) {
            console.error('Error:', error);
            alert('Error updating ticket');
        }
    });

    // Initialize the queries table
    loadCallQueries();
});
</script>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // Function to format time
    function formatTime(hours, minutes, seconds) {
        // Handle negative values
        if (hours < 0 || minutes < 0 || seconds < 0) {
            return "00:00:00";
        }
        return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    }

    // Function to update a single timer
    function updateCreatedTimer(timerElement) {
        // Get the created_at time from the data attribute
        let createdAtStr = timerElement.dataset.createdAt;

        // Convert to local timezone
        const createdAt = new Date(createdAtStr);
        const status = timerElement.dataset.status;

        // Don't update timer if ticket is closed or resolved
        if (status === 'closed' || status === 'resolved') {
            return;
        }

        const now = new Date();

        // Ensure proper timezone handling
        const diff = now - createdAt;

        // Prevent negative values
        if (diff < 0) {
            timerElement.textContent = "00:00:00";
            return;
        }

        const hours = Math.floor(diff / (1000 * 60 * 60));
        const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((diff % (1000 * 60)) / 1000);

        timerElement.textContent = formatTime(hours, minutes, seconds);
    }

    // Update all timers
    function updateAllCreatedTimers() {
        const timerElements = document.querySelectorAll('.created-timer-span');
        timerElements.forEach(updateCreatedTimer);
    }

    // Initial update
    updateAllCreatedTimers();

    // Update every second
    setInterval(updateAllCreatedTimers, 1000);
});



// Format large time durations
function formatLongDuration(hours) {
    if (hours >= 24) {
        const days = Math.floor(hours / 24);
        const remainingHours = hours % 24;
        return `${days}d ${String(remainingHours).padStart(2, '0')}:`;
    }
    return String(hours).padStart(2, '0') + ':';
}

// Update the timer update function to handle long durations
function updateCreatedTimer(timerElement) {
    const createdAt = new Date(timerElement.dataset.createdAt + 'Z');
    const status = timerElement.dataset.status;

    if (status === 'closed' || status === 'resolved') {
        return;
    }

    const now = new Date();
    const diff = now - createdAt;

    const hours = Math.floor(diff / (1000 * 60 * 60));
    const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((diff % (1000 * 60)) / 1000);

    const formattedTime = formatLongDuration(hours) +
        String(minutes).padStart(2, '0') + ':' +
        String(seconds).padStart(2, '0');

    timerElement.textContent = formattedTime;

    // Add warning class for long-running tickets
    if (hours >= 24) {
        timerElement.classList.add('long-running');
    }
}
</script>




{% block extra_js %}
<!-- Make sure these are in the correct order -->
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
<div id="notification-container"></div>
<audio id="notificationSound" src="{% static 'employee/sounds/notification.mp3' %}" preload="auto"></audio>
<script src="{% static 'employee/js/notifications.js' %}"></script>

<script>
    // Initialize notification manager
    document.addEventListener('DOMContentLoaded', function() {
        // Make sure notificationManager is available globally
        window.notificationManager = window.notificationManager || new NotificationManager();
    });
</script>
{% endblock %}

<script>
function handleLogout(event) {
    event.preventDefault();

    // Make an AJAX call to the logout endpoint
    fetch('/logout', {
        method: 'GET',
        headers: {
            'X-Requested-With': 'XMLHttpRequest',
        },
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'error') {
            // Create a formatted list of tickets grouped by status
            let ticketList = Object.entries(data.tickets).map(([status, tickets]) => {
                const ticketsInStatus = tickets.map(ticket =>
                    `   • ${ticket.ticket_id}: ${ticket.subject}`
                ).join('\n');
                return `${status} Tickets:\n${ticketsInStatus}`;
            }).join('\n\n');

            // Show the alert with Sweetalert2
            Swal.fire({
                title: 'Cannot Logout',
                html: `<div class="alert alert-warning">
                    <p>You have the following unresolved tickets that need to be assigned to another agent:</p>
                    <pre class="text-left">${ticketList}</pre>
                    <p class="mt-3">Please assign these tickets to another agent before logging out.</p>
                </div>`,
                icon: 'warning',
                confirmButtonText: 'OK',
                customClass: {
                    container: 'my-swal',
                    popup: 'my-swal-popup'
                }
            });
        } else if (data.status === 'success') {
            // Show a success message and redirect
            Swal.fire({
                title: 'Success',
                text: 'You have been successfully logged out.',
                icon: 'success',
                timer: 1500,
                showConfirmButton: false
            }).then(() => {
                window.location.href = '/login';
            });
        }
    })
    .catch(error => {
        console.error('Error:', error);
        // If there's an error, redirect to login page anyway
        window.location.href = '/login';
    });
}

// Add event listener to logout link/button
document.addEventListener('DOMContentLoaded', function() {
    const logoutLink = document.querySelector('a[href="/logout"]');
    if (logoutLink) {
        logoutLink.addEventListener('click', handleLogout);
    }
});
</script>
<script>
function toggleRow(cell) {
    const row = cell.closest('tr');
    const expandedRow = row.nextElementSibling;

    if (expandedRow.classList.contains('hidden')) {
        expandedRow.classList.remove('hidden');
        cell.textContent = '-';
    } else {
        expandedRow.classList.add('hidden');
        cell.textContent = '+';
    }
}
</script>

<script>
// Right Sidebar Hover Effect
const rightSidebar = document.getElementById('rightSidebar');
document.body.addEventListener('mousemove', (event) => {
    if (event.clientY >= 100 && event.clientY <= 230 && event.clientX > window.innerWidth - 50) {
        rightSidebar.classList.remove('translate-x-full');
    } else {
        rightSidebar.classList.add('translate-x-full');
    }
});

// Chart Data
document.addEventListener('DOMContentLoaded', function() {
    // Get data from Django template context
    const statusCounts = {
        total: {{ total_tickets|default:0 }},
        open: 0,
        waiting: 0,
        pending: 0,
        resolved: 0,
        closed: 0,
        onHold: 0,
        initial: 0
    };

    // Process ticket_status_counts from Django
    {% for status in ticket_status_counts %}
        switch ('{{ status.status }}') {
            case 'open':
                statusCounts.open = {{ status.count }};
                break;
            case 'waiting_on_customer':
                statusCounts.waiting = {{ status.count }};
                break;
            case 'pending':
                statusCounts.pending = {{ status.count }};
                break;
            case 'resolved':
                statusCounts.resolved = {{ status.count }};
                break;
            case 'closed':
                statusCounts.closed = {{ status.count }};
                break;
            case 'on_hold':
                statusCounts.onHold = {{ status.count }};
                break;
            case 'initial_response':
                statusCounts.initial = {{ status.count }};
                break;
        }
    {% endfor %}

    // Today's data
    const todayData = {
        total: {{ todays_tickets|default:0 }},
        open: {{ open_tickets|default:0 }},
        closed: {{ closed_tickets|default:0 }}
    };

    // Pie Chart Configuration
    const doughnutData = {
        labels: ['Total Tickets', 'Open', 'Waiting On Customer', 'Pending', 'Resolved', 'Closed', 'On Hold', 'Initial Response'],
        datasets: [{
            label: 'Counts',
            data: [
                statusCounts.total,
                statusCounts.open,
                statusCounts.waiting,
                statusCounts.pending,
                statusCounts.resolved,
                statusCounts.closed,
                statusCounts.onHold,
                statusCounts.initial
            ],
            backgroundColor: ['#d83369', '#ff9800', '#ea3610', '#eed910', '#93ee10', '#10ee38', '#10cfee', '#1035ee'],
        }]
    };

    // Bar Chart Configuration
    const barData = {
        labels: ['Today Tickets', 'Open Tickets', 'Closed Tickets'],
        datasets: [{
            label: 'Counts',
            data: [todayData.total, todayData.open, todayData.closed],
            backgroundColor: '#2196f3',
            borderRadius: 10,
        }]
    };

    // Chart Configurations
    const doughnutChartConfig = {
        type: 'doughnut',
        data: doughnutData,
        options: {
            responsive: true,
            plugins: {
                legend: {
                    position: 'bottom'
                }
            }
        }
    };

    const barChartConfig = {
        type: 'bar',
        data: barData,
        options: {
            responsive: true,
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        stepSize: 1
                    }
                }
            },
            plugins: {
                legend: {
                    display: false
                }
            }
        }
    };

    // Populate Data Table
    const tableBody = document.getElementById("dataTable");
    doughnutData.labels.forEach((label, index) => {
        let row = `<tr>
                    <td class="px-2 py-1 flex items-center">
                        <span class="w-4 h-4 inline-block rounded-full mr-2"
                              style="background-color: ${doughnutData.datasets[0].backgroundColor[index]};"></span>
                        ${label}
                    </td>
                    <td class="px-2 py-1 text-center">${doughnutData.datasets[0].data[index]}</td>
                </tr>`;
        tableBody.innerHTML += row;
    });

    // Initialize Charts
    const pieChart = new Chart(document.getElementById('pieChart').getContext('2d'), doughnutChartConfig);
    const barChart = new Chart(document.getElementById('barChart').getContext('2d'), barChartConfig);
});
</script>
{% endblock %}