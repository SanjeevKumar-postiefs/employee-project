{% extends 'base.html' %}
{% load static %}
{% load custom_filters %}
{% load timedelta_filters %}
{% load duration_filters %}
{% csrf_token %}
{% block content %}


{% block extra_head %}
<style>
  .main-content {
    margin-left: 0px;
    transition: margin-left 0.3s ease;
  }

  .content-area {
    margin-top: 64px;
    overflow: auto;
    height: calc(100vh - 64px);
  }

  /* Break toggle animation */
  .peer-checked:after:translate-x-full {
    transform: translateX(100%);
  }

  /* Status text animation */
  @keyframes statusPing {
    75%, 100% {
      transform: scale(2);
      opacity: 0;
    }
  }

  .status-ping::after {
    content: '';
    position: absolute;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background-color: currentColor;
    animation: statusPing 1s cubic-bezier(0, 0, 0.2, 1) infinite;
  }

  /* Call Details Table specific styles */
.call-details-table {
    border-collapse: separate;
    border-spacing: 0;
}

.call-details-table thead th {
    background-color: #F3F4F6;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
}

.call-details-table tbody tr:last-child {
    border-bottom: none;
}

/* Hover effect */
.call-details-table tbody tr:hover {
    background-color: #F9FAFB;
    transition: background-color 0.2s ease;
}

/* Responsive padding for mobile */
@media (max-width: 640px) {
    .call-details-table th,
    .call-details-table td {
        padding: 0.75rem 0.5rem;
    }
}

/* Right Sidebar Styles */
#rightSidebar {
    width: 400px;
    box-shadow: -2px 0 10px rgba(0,0,0,0.1);
}

/* Chart Container Styles */
.chart-container {
    position: relative;
    height: 300px;
}

/* Summary Section Hover Effects */
.bg-gray-100:hover {
    background-color: #f7fafc;
    transition: background-color 0.3s ease;
}

/* Data Table Hover Effects */
#dataTable tr:hover {
    background-color: #f9fafb;
}

/* Responsive Adjustments */
@media (max-width: 768px) {
    #rightSidebar {
        width: 100%;
    }
}

/* Priority Colors */
td[data-priority="urgent"] {
    background-color: #ef4444 !important; /* red-500 */
    color: white !important;
}

td[data-priority="high"] {
    background-color: #f97316 !important; /* orange-500 */
    color: white !important;
}

td[data-priority="medium"] {
    background-color: #facc15 !important; /* yellow-400 */
    color: #713f12 !important; /* yellow-900 */
}

td[data-priority="low"] {
    background-color: #22c55e !important; /* green-500 */
    color: white !important;
}

/* Status Colors */
td[data-status="open"] {
    background-color: #ff9800 !important; /* Orange */
    color: white !important;
}

td[data-status="pending"] {
    background-color: #dc3545 !important; /* Red */
    color: white !important;
}

td[data-status="resolved"] {
    background-color: #007bff !important; /* Blue */
    color: white !important;
}

td[data-status="closed"] {
    background-color: #007bff !important; /* Blue */
    color: white !important;
}

td[data-status="waiting_on_customer"] {
    background-color: #ffc107 !important; /* Yellow */
    color: white !important;
}

td[data-status="initial_response"] {
    background-color: #28a745 !important; /* Green */
    color: white !important;
}

td[data-status="on_hold"] {
    background-color: #ffc107 !important; /* Yellow */
    color: white !important;
}


/* Time Display Styles */
.created-timer-span {
    display: inline-block;
    padding: 0.25rem 0.5rem;
    font-family: monospace;
}


/* Break Toggle Container */

.break-toggle-container {
    display: flex;
    align-items: center;
    padding: 8px 16px;
    border-radius: 12px;
    background: #f8fafc;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.04);
}

/* Status Toggle Wrapper */
.status-toggle-wrapper {
    display: flex;
    align-items: center;
    gap: 12px;
}

/* Modern Switch */
.modern-switch {
    position: relative;
    display: inline-block;
    width: 60px;
    height: 30px;
    margin: 0;
}

.modern-switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

/* Slider Background */
.modern-slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #e2e8f0;
    transition: 0.4s;
    border-radius: 34px;
    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
}

/* Toggle Circle */
.toggle-circle {
    position: absolute;
    content: "";
    height: 24px;
    width: 24px;
    left: 3px;
    bottom: 3px;
    background-color: white;
    transition: 0.4s;
    border-radius: 50%;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

/* Active State */
.modern-switch input:checked + .modern-slider {
    background-color: #ef4444;
}

.modern-switch input:checked + .modern-slider .toggle-circle {
    transform: translateX(30px);
}

/* Status Indicator */
.status-indicator {
    display: flex;
    align-items: center;
    gap: 8px;
    font-weight: 500;
}

/* Status Text */
.status-text {
    font-size: 0.95rem;
    font-weight: 600;
    transition: all 0.3s ease;
}

.status-text.active {
    color: #22c55e;
}

.status-text.break {
    color: #ef4444;
}

/* Status Dot */
.status-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background-color: #22c55e;
    position: relative;
    transition: all 0.3s ease;
}

/* Status Dot Animation */
.status-dot::after {
    content: '';
    position: absolute;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: inherit;
    opacity: 0.4;
    animation: pulse 1.5s infinite;
}

/* Break State */
.break ~ .status-dot {
    background-color: #ef4444;
}

/* Hover Effects */
.modern-slider:hover {
    opacity: 0.9;
}

.modern-switch input:focus + .modern-slider {
    box-shadow: 0 0 1px #2196F3;
}

/* Pulse Animation */
@keyframes pulse {
    0% {
        transform: scale(1);
        opacity: 0.4;
    }
    50% {
        transform: scale(2);
        opacity: 0;
    }
    100% {
        transform: scale(1);
        opacity: 0;
    }
}

/* Disable styles */
.modern-switch input:disabled + .modern-slider {
    opacity: 0.6;
    cursor: not-allowed;
}

/* Hover animations */
.break-toggle-container:hover {
    transform: translateY(-1px);
    transition: transform 0.2s ease;
}

/* Media Query for smaller screens */
@media (max-width: 640px) {
    .break-toggle-container {
        padding: 6px 12px;
    }

    .modern-switch {
        width: 50px;
        height: 26px;
    }

    .toggle-circle {
        height: 20px;
        width: 20px;
    }

    .modern-switch input:checked + .modern-slider .toggle-circle {
        transform: translateX(24px);
    }

    .status-text {
        font-size: 0.875rem;
    }
}

/* Break Toggle Container */



/* Status Dropdown Styles */

.dropdown {
    position: relative;
    display: inline-block;
}

.dropdown-menu {
    min-width: 120px;
    background: white;
    border: 1px solid #e2e8f0;
    border-radius: 0.375rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    padding: 0.25rem 0;
    position: absolute;
    left: 0;
    z-index: 50;
    width: max-content;
}

.dropdown-menu.bottom-full {
    bottom: 100%;
}

.dropdown-menu.top-full {
    top: 100%;
}

.dropdown-item {
    padding: 0.375rem 0.75rem;
    color: #4a5568;
    transition: all 0.2s ease;
    font-size: 0.875rem;
    display: block;
    width: 100%;
    text-align: left;
    border: none;
    background: none;
    cursor: pointer;
    white-space: nowrap;
}

.dropdown-item:hover {
    background-color: #f3f4f6;
    color: #1e40af;
}

.dropdown-item:active {
    background-color: #e5e7eb;
}

.hidden {
    display: none;
}

/* Animation for dropdown */
.dropdown-menu:not(.hidden) {
    animation: fadeIn 0.1s ease-in-out;
}

@keyframes fadeIn {
    from {
        opacity: 0;
        transform: translateY(var(--translate-direction, -10px));
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Status Dropdown Styles */


/* Subject cell styles */
    .subject-cell {
        max-width: 256px; /* w-64 equivalent */
        position: relative;
    }

    /* Truncate text with ellipsis */
    .truncate-text {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        position: relative;
    }

    /* Hover tooltip */
    .truncate-text:hover::after {
        content: attr(title);
        position: absolute;
        left: 0;
        top: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 12px 18px;
        border-radius: 10px;
        font-size: 10rem;
        white-space: normal;
        max-width: 600px;
        min-width: 300px;
        z-index: 50;
        word-wrap: break-word;
        line-height: 100.5;
    }

    /* Add shadow and styling to the tooltip */
    .truncate-text:hover::after {
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
/* Subject cell styles */


/* Note cell styles */
.note-cell {
    max-width: 256px;
    position: relative;
}

.truncate-text {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    position: relative;
}

.truncate-text:hover::after {
    content: attr(title);
    position: absolute;
    left: 0;
    top: 100%;
    background-color: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 1rem;
    white-space: normal;
    max-width: 600px;
    min-width: 300px;
    z-index: 50;
    word-wrap: break-word;
    line-height: 1.5;
}

.truncate-text:hover::after {
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

/* Add borders to table cells */
.call-details-table td,
.call-details-table th {
    border: 1px solid #e5e7eb;
}


/* Acknowledge Button Styles */
.acknowledge-button {
    background-color: #dc3545;
    color: white;
    padding: 0.375rem 0.75rem;
    border-radius: 0.25rem;
    border: none;
    cursor: pointer;
    transition: background-color 0.15s ease-in-out;
}

.acknowledge-button:hover {
    background-color: #c82333;
}

.acknowledge-button:disabled {
    opacity: 0.65;
    cursor: not-allowed;
}

.text-success {
    color: #28a745;
}
/* Acknowledge Button Styles */

















/* Time Column Base Styles */
.time-column {
    transition: all 0.3s ease;
    position: relative;
}

.timer-span {
    position: relative;
    z-index: 2;
}

/* Priority-based Animations */
@keyframes pulse-urgent {
    0% {
        background-color: rgba(239, 68, 68, 0.7); /* #ef4444 with opacity */
        color: white;
    }
    50% {
        background-color: rgba(239, 68, 68, 0.9); /* #ef4444 with higher opacity */
        color: white;
    }
    100% {
        background-color: rgba(239, 68, 68, 0.7); /* #ef4444 with opacity */
        color: white;
    }
}

@keyframes pulse-high {
    0% {
        background-color: rgba(249, 115, 22, 0.7); /* #f97316 with opacity */
        color: white;
    }
    50% {
        background-color: rgba(249, 115, 22, 0.9); /* #f97316 with higher opacity */
        color: white;
    }
    100% {
        background-color: rgba(249, 115, 22, 0.7); /* #f97316 with opacity */
        color: white;
    }
}

@keyframes pulse-medium {
    0% {
        background-color: rgba(250, 204, 21, 0.7); /* #facc15 with opacity */
        color: #713f12;
    }
    50% {
        background-color: rgba(250, 204, 21, 0.9); /* #facc15 with higher opacity */
        color: #713f12;
    }
    100% {
        background-color: rgba(250, 204, 21, 0.7); /* #facc15 with opacity */
        color: #713f12;
    }
}

@keyframes pulse-low {
    0% {
        background-color: rgba(34, 197, 94, 0.7); /* #22c55e with opacity */
        color: white;
    }
    50% {
        background-color: rgba(34, 197, 94, 0.9); /* #22c55e with higher opacity */
        color: white;
    }
    100% {
        background-color: rgba(34, 197, 94, 0.7); /* #22c55e with opacity */
        color: white;
    }
}

/* Total Time Column Priority Styles */
.time-column.total-time.priority-urgent {
    animation: pulse-urgent 2s infinite !important;
}

.time-column.total-time.priority-high {
    animation: pulse-high 2s infinite !important;
}

.time-column.total-time.priority-medium {
    animation: pulse-medium 2s infinite !important;
}

.time-column.total-time.priority-low {
    animation: pulse-low 2s infinite !important;
}

/* Individual Time Column Priority Styles */
.time-column.individual-time.exceeded.priority-urgent {
    animation: pulse-urgent 2s infinite;
}

.time-column.individual-time.exceeded.priority-high {
    animation: pulse-high 2s infinite;
}

.time-column.individual-time.exceeded.priority-medium {
    animation: pulse-medium 2s infinite;
}

.time-column.individual-time.exceeded.priority-low {
    animation: pulse-low 2s infinite;
}



/* Notifications Styling */
.notifications-popup {
    background: #ffffff !important;
    border-radius: 12px !important;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15) !important;
    margin-top: 20px !important;
}

.notifications-container {
    max-height: 80vh;
    overflow-y: auto;
}

.notifications-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 20px;
    border-bottom: 1px solid #eee;
    background: #f8f9fa;
    border-radius: 12px 12px 0 0;
}

.notifications-header h4 {
    margin: 0;
    color: #2c3e50;
    font-size: 1.1rem;
    font-weight: 600;
}

.notifications-list {
    padding: 10px;
}

.notification-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px;
    margin-bottom: 8px;
    border-radius: 8px;
    background: white;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    animation: slideIn 0.3s ease-out;
}

.notification-content {
    flex: 1;
    margin-right: 10px;
}

.notification-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 5px;
}

.ticket-id {
    font-weight: 600;
    color: #2c3e50;
}

.priority-badge {
    padding: 3px 8px;
    border-radius: 12px;
    font-size: 0.8rem;
    font-weight: 500;
}

.priority-badge.urgent { background: #ff4444; color: white; }
.priority-badge.high { background: #ffbb33; color: black; }
.priority-badge.medium { background: #ff8800; color: white; }
.priority-badge.low { background: #00C851; color: white; }

.notification-body {
    font-size: 0.9rem;
}

.subject {
    color: #2c3e50;
    margin-bottom: 3px;
}

.time-exceeded {
    color: #666;
    font-size: 0.8rem;
}

.dismiss-ticket, .dismiss-all {
    background: none;
    border: none;
    padding: 5px;
    cursor: pointer;
    transition: opacity 0.2s;
}

.dismiss-ticket:hover, .dismiss-all:hover {
    opacity: 0.7;
}

.dismiss-all {
    background: #e74c3c;
    color: white;
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 0.9rem;
}

@keyframes slideIn {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
}

@keyframes slideOut {
    from { transform: translateX(0); opacity: 1; }
    to { transform: translateX(100%); opacity: 0; }
}


.ticket-notification {
    background-color: #fff;
    border: 1px solid #ddd;
    border-left: 4px solid #0d6efd;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    margin-bottom: 10px;
    padding: 15px;
    width: 350px;
}

#notification-container {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 1050;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.ticket-notification .notification-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.ticket-notification .notification-body {
    margin-bottom: 10px;
}

.ticket-notification .notification-actions {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
}


.ticket-alert {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 1050;
    width: 350px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    border-left: 4px solid #0366d6;
    animation: slideIn 0.5s ease-out;
}

.ticket-alert.priority-urgent {
    border-left-color: #dc3545;
}

.ticket-alert.priority-high {
    border-left-color: #fd7e14;
}

.alert-header {
    padding: 12px 15px;
    border-bottom: 1px solid #e1e4e8;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.alert-body {
    padding: 15px;
}

.alert-actions {
    padding: 10px 15px;
    border-top: 1px solid #e1e4e8;
    display: flex;
    justify-content: flex-end;
    gap: 10px;
}

@keyframes slideIn {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

.notification-item .message {
    color: #666;
    font-size: 0.9rem;
    margin-top: 5px;
}

.notification-actions {
    display: flex;
    gap: 8px;
    align-items: center;
}

.notification-item {
    border-left: 4px solid transparent;
}

.notification-item.priority-urgent { border-left-color: #ff4444; }
.notification-item.priority-high { border-left-color: #ffbb33; }
.notification-item.priority-medium { border-left-color: #ff8800; }
.notification-item.priority-low { border-left-color: #00C851; }






    .tooltip {
    visibility: hidden;
    position: absolute;
    z-index: 50;
  }

  .has-tooltip:hover .tooltip {
    visibility: visible;
  }

  /* For timer animations */
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: .5; }
  }

  .animate-pulse {
    animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
  }

  /* Preserve existing functionality styles */
  .start-button.paused-by-call,
  .start-button.blocked {
    opacity: 0.7;
    cursor: not-allowed !important;
    background-color: #6c757d !important;
    border-color: #6c757d !important;
    pointer-events: all !important;
  }



/* Base Container Styles */
.call-action-form {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100%;
    margin: 0;
    padding: 0;
}

/* Base Button Styles - Common properties for all buttons */
.start-button,
.call-action-form button {
    /* Display and Alignment */
    display: inline-flex;
    align-items: center;
    justify-content: center;

    /* Dimensions */
    height: 32px;
    width: 70px;

    /* Spacing */
    padding: 0 0.25rem; /* Reduced horizontal padding */

    /* Typography */
    font-size: 0.875rem;
    line-height: 1;

    /* Border and Shape */
    border: 1px solid;
    border-radius: 0.25rem;

    /* Interaction */
    cursor: pointer;
    transition: all 0.2s ease;

    /* Width Behavior */
    white-space: nowrap; /* Prevents text wrapping */
}

/* Start Button Specific Styles */
.start-button {
    color: #22c55e !important;
    background-color: #dcfce7 !important;
    border-color: #22c55e !important;
}

/* Call Button Specific Styles */
.call-action-form button {
    margin: 0 !important;
    color: white !important;
    background-color: #9ca3af !important;
    border-color: #9ca3af !important;
}








.max-w-full.mx-auto.bg-white {
    padding: .5rem;
    margin: 0;
    width: 100%;
    border-radius: 0.5rem;
}


.text-sm th {
    text-align: center !important;
}

.text-sm th{
    padding: 0.75rem !important;
    vertical-align: middle !important;
    white-space: nowrap;
}



</style>

{% endblock %}





<!-- Dashboard Page -->
<div class="main-content">
<div class="p-1 content-area">
<div class="max-w-full mx-auto bg-white p-6 shadow-lg rounded-lg overflow-x-auto">
    <div class="flex justify-between items-center mb-7">
        <h1 class="text-4xl font-bold bg-gradient-to-r from-indigo-500 via-purple-500 to-pink-500 bg-clip-text text-transparent animate-gradient hover:scale-105 transition-transform duration-200 tracking-tight">
            Dashboard
        </h1>
            <div class="break-toggle-container">
                <form action="{% url 'toggle_break_status' %}" method="post" id="breakToggleForm" class="d-flex align-items-center" onsubmit="return false;">
                {% csrf_token %}
                    <div class="status-toggle-wrapper">
                        <label class="modern-switch">
                            <input type="checkbox" id="breakToggle" {% if employee_profile.is_on_break %}checked{% endif %}>
                            <span class="modern-slider">
                            <span class="toggle-circle"></span>
                            </span>
                        </label>
                        <div class="status-indicator">
                            <span id="breakStatus" class="status-text {% if employee_profile.is_on_break %}break{% else %}active{% endif %}">
                                {% if employee_profile.is_on_break %}
                                On Break
                                {% else %}
                                Active
                                {% endif %}
                            </span>
                    <span class="status-dot"></span>
                </div>
            </div>
        </form>
    </div>
</div>

    <!-- Ticket Table with Actions -->

  <div class="max-w-full mx-auto bg-white shadow-lg rounded-lg">
      <h1 class="text-2xl font-bold mb-6">Tickets Table</h1>

    <table class="w-full border-collapse border border-gray-300">
      <thead class="text-sm">
        <tr class="bg-blue-200">
          <th class="border p-1 w-4"></th>
          <th class="border p-1 w-6">Ticket ID</th>
          <th class="border p-1 w-64">Subject</th>
          <th class="border p-1 w-5">Priority</th>
          <th class="border p-1 w-6">Status</th>
          <th class="border p-1 w-6">Ticket Age</th>
          <th class="border p-1 w-6">Total Effort</th>
          <th class="border p-1 w-2">Indiv Effort</th>
          <th class="border p-1 w-6">Action</th>
          <th class="border p-1 w-6">On Call</th>
          <th class="border p-1 w-6">Accept</th>
        </tr>
      </thead>
      <tbody class="text-center">
        {% for ticket in tickets %}
          {% if ticket.status != 'closed' and ticket.status != 'resolved' %}
          <!-- Empty row for spacing -->
          <tr><td colspan="11" class="h-1"></td></tr>

          <!-- Main Ticket Row -->
          <tr class="border border-l-4 border-blue-500 bg-gray-100 hover:bg-gray-200"
              data-ticket-id="{{ ticket.id }}"
              data-priority="{{ ticket.priority|lower }}"
              data-created-at="{{ ticket.created_at|date:'Y-m-d H:i:s' }}">

            <td class="border px-2 py-1 text-center cursor-pointer" onclick="toggleRow(this)">+</td>
            <td class="border px-2 py-1">{{ ticket.ticket_id }}</td>
            <td class="border px-2 py-1 text-left subject-cell">
                <div class="truncate-text" title="{{ ticket.subject }}">
                    {{ ticket.subject }}
                </div>
            </td>
            <td class="border px-2 py-1" data-priority="{{ ticket.priority|lower }}">
                {{ ticket.priority|priority_abbreviation }}
            </td>
            <td class="border px-2 py-1" data-status="{{ ticket.status|lower }}">
                <span class=" full relative group cursor-help"
                      title="{{ ticket.status|status_full_name }}"
                      data-tooltip="{{ ticket.status }}">
                    {{ ticket.status|status_abbreviation }}
                </span>
            </td>
            <td class="border px-2 py-1 text-center">
                <span id="created-timer-{{ ticket.id }}"
                      class="created-timer-span priority-{{ ticket.priority|lower }}"
                      data-created-at="{{ ticket.created_at|localize_datetime|date:'c' }}"
                      data-status="{{ ticket.status }}"
                      data-priority="{{ ticket.priority|lower }}"
                      title="Created: {{ ticket.created_at|date:'F j, Y, g:i a' }}">
                    {{ ticket.time_since_created }}
                </span>
            </td>
            <!-- Replace your existing Total Spent column with this -->
            <td class="border px-2 py-1 text-center time-column total-time {% if ticket.has_exceeded_time_limit %}priority-{{ ticket.priority|lower }}{% endif %}">
                <span id="timer-{{ ticket.id }}"
                      class="timer-span"
                      data-ticket-id="{{ ticket.id }}">
                    {{ ticket.time_spent|format_duration }}
                </span>
            </td>

<!-- Replace your existing Individual Spent column with this -->
            <td class="border px-2 py-1 text-center time-column individual-time {% if ticket.has_exceeded_time_limit and not ticket.status_changed %}exceeded priority-{{ ticket.priority|lower }}{% endif %}">
                <span id="individual-timer-{{ ticket.id }}"
                      class="timer-span"
                      data-ticket-id="{{ ticket.id }}">
                    {{ ticket.individual_time_spent|format_duration }}
                </span>
            </td>
            <td class="border px-2 py-1 text-center">
                <input type="hidden" name="csrfmiddlewaretoken" value="{{ csrf_token }}">
                <button class="start-button" data-ticket-id="{{ ticket.id }}">
                    {% if ticket.is_active %}Stop{% else %}Start{% endif %}
                </button>
            </td>
            <td class="border px-2 py-1 text-center" style="vertical-align: middle;">
                <form method="post" action="{% url 'start_end_call' ticket.id %}"
                      class="call-action-form" data-ticket-id="{{ ticket.id }}">
                    {% csrf_token %}
                    {% if ticket.call_in_progress %}
                        <input type="hidden" name="action" value="end_call">
                        <button type="submit">End Call</button>
                    {% else %}
                        <input type="hidden" name="action" value="start_call">
                        <button type="submit">Start Call</button>
                    {% endif %}
                </form>
            </td>
            <td class="border px-2 py-1 text-center">
                {% if ticket.assigned_to == request.user %}
                    {% if not ticket.is_acknowledged %}
                        <button class="btn btn-primary btn-sm acknowledge-button"
                                data-ticket-id="{{ ticket.id }}"
                                data-acknowledge-button="true">
                            Accept
                        </button>
                    {% else %}
                        <span class="text-success">✅</span>
                    {% endif %}
                {% endif %}
            </td>
          </tr>

          <!-- Expanded Row -->
          <tr class="hidden text-left bg-gray-100" id="expanded-row-{{ ticket.id }}">
            <td colspan="11" class="py-2 px-4">
              <a href="{% url 'assign_ticket' ticket.id %}"
                 class="text-white bg-blue-700 hover:bg-blue-800 focus:ring-1 focus:ring-blue-300 font-medium text-sm px-5 py-2.5 me-2 mb-2">
                Assign
              </a>

              <div class="dropdown inline-block">
    <button class="text-white bg-blue-700 hover:bg-blue-800 focus:ring-1 focus:ring-blue-300 font-medium text-sm px-5 py-2.5 me-2 mb-2 dropdown-toggle"
            type="button"
            id="statusDropdown-{{ ticket.id }}"
            data-ticket-id="{{ ticket.id }}"
            aria-expanded="false">
        Change Status
    </button>
    <ul class="dropdown-menu hidden absolute z-10 bg-white border rounded shadow-lg"
        aria-labelledby="statusDropdown-{{ ticket.id }}">
        {% for status in ticket_statuses %}
            {% if status.0 != ticket.status %}
                <li>
                    <a class="dropdown-item block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 cursor-pointer change-status"
                       data-ticket-id="{{ ticket.id }}"
                       data-new-status="{{ status.0 }}">
                        {{ status.1 }}
                    </a>
                </li>
            {% endif %}
        {% endfor %}
    </ul>
</div>

              <a href="{% url 'view_call_details' ticket.id %}"
                 class="text-white bg-blue-700 hover:bg-blue-800 focus:ring-1 focus:ring-blue-300 font-medium text-sm px-5 py-2.5 me-2 mb-2">
                Call Details
              </a>

              <a href="{% url 'view_ticket_notes' ticket.id %}"
                 class="text-white bg-blue-700 hover:bg-blue-800 focus:ring-1 focus:ring-blue-300 font-medium text-sm px-5 py-2.5 me-2 mb-2">
                From existing query
              </a>

                <a href="{% url 'view_ticket_notes_all' ticket.id %}"
                 class="text-white bg-blue-700 hover:bg-blue-800 focus:ring-1 focus:ring-blue-300 font-medium text-sm px-5 py-2.5 me-2 mb-2">
                all notes
              </a>
            </td>
          </tr>
          {% endif %}
        {% endfor %}
      </tbody>
    </table>
  </div>


<!-- Post-Call Details Modal (Tailwind) -->
<div id="postCallModal" class="fixed inset-0 z-50 hidden overflow-y-auto" aria-labelledby="postCallModalLabel">
    <div class="flex min-h-screen items-center justify-center p-4">
        <!-- Modal backdrop -->
        <div class="fixed inset-0 bg-black bg-opacity-50 transition-opacity"></div>

        <!-- Modal content -->
        <div class="relative w-full max-w-md transform rounded-lg bg-white shadow-xl transition-all">
            <!-- Modal header -->
            <div class="flex items-center justify-between border-b p-4">
                <h5 class="text-xl font-semibold text-gray-900" id="postCallModalLabel">
                    Post-Call Details
                </h5>
                <button type="button" class="text-gray-400 hover:text-gray-500" data-dismiss="modal">
                    <span class="sr-only">Close</span>
                    <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>

            <!-- Modal form -->
            <form id="postCallForm" method="post">
                <div class="p-6">
                    {% csrf_token %}
                    <input type="hidden" name="ticket_id" id="modal-ticket-id" value="">

                    <!-- Ticket ID field -->
                    <div class="mb-4">
                        <label for="modal-ticket-id-display" class="block text-sm font-medium text-gray-700">
                            Ticket ID:
                        </label>
                        <input type="text"
                               id="modal-ticket-id-display"
                               class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 bg-gray-50"
                               readonly>
                    </div>

                    <!-- Subject field -->
                    <div class="mb-4">
                        <label for="modal-subject" class="block text-sm font-medium text-gray-700">
                            Subject:
                        </label>
                        <input type="text"
                               id="modal-subject"
                               class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 bg-gray-50"
                               readonly>
                    </div>

                    <!-- Status field -->
                    <div class="mb-4">
                        <label for="modal-status" class="block text-sm font-medium text-gray-700">
                            Status:
                        </label>
                        <select id="modal-status"
                                name="status"
                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                            {% for status in ticket_statuses %}
                                <option value="{{ status.0 }}">{{ status.1 }}</option>
                            {% endfor %}
                        </select>
                    </div>

                    <!-- Call Note field -->
                    <div class="mb-4">
                        <label for="modal-call-note" class="block text-sm font-medium text-gray-700">
                            Call Note:
                        </label>
                        <textarea name="note"
                                  id="modal-call-note"
                                  rows="4"
                                  class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                                  placeholder="Describe the call..."></textarea>
                    </div>
                </div>

                <!-- Modal footer -->
                <div class="border-t px-6 py-4 flex justify-end space-x-3">
                    <button type="button"
                            class="rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
                            data-dismiss="modal">
                        Close
                    </button>
                    <button type="submit"
                            class="rounded-md bg-blue-600 px-4 py-2 text-sm font-medium text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                        Save
                    </button>
                </div>
            </form>
        </div>
    </div>
</div>




<!-- Client Call Modal with question: Is it a new query? -->
<div id="clientCallModal" class="hidden fixed inset-0 z-50 overflow-auto bg-black bg-opacity-50">
    <div class="relative p-8 bg-white w-full max-w-2xl mx-auto my-10 rounded-lg shadow-lg">
        <!-- Modal Header -->
        <div class="flex justify-between items-center border-b pb-4">
            <h5 class="text-xl font-semibold">Client Call</h5>
            <button type="button"
        onclick="closeModal()"
        class="text-gray-400 hover:text-gray-500 focus:outline-none">
    <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
    </svg>
</button>
        </div>

        <!-- Modal Body -->
        <div class="mt-6">
            <!-- Query Type Selection -->
            <div class="text-center mb-8">
                <h5 class="text-lg font-medium mb-4">Is it a new query?</h5>
                <div class="flex justify-center space-x-8">
                    <button type="button" class="query-option" onclick="showSection('new')">
    <div class="flex items-center space-x-2">
        <div class="w-6 h-6 rounded-full border-2 border-blue-500 flex items-center justify-center">
            <div class="query-circle w-4 h-4 rounded-full bg-transparent transition-colors duration-200"></div>
        </div>
        <span class="text-gray-700">New Query</span>
    </div>
</button>
<button type="button" class="query-option" onclick="showSection('existing')">
    <div class="flex items-center space-x-2">
        <div class="w-6 h-6 rounded-full border-2 border-blue-500 flex items-center justify-center">
            <div class="query-circle w-4 h-4 rounded-full bg-transparent transition-colors duration-200"></div>
        </div>
        <span class="text-gray-700">Existing Query</span>
    </div>
</button>
                </div>
            </div>


<!-- Forms Container -->
<div class="mt-6">
<!-- New Query Form (Initially Hidden) -->
<div id="newQuerySection" class="query-section" style="display: none; margin-top: 20px;">
    <form id="newQueryForm" method="post" class="space-y-4">
        {% csrf_token %}
        <!-- Ticket Toggle -->
        <div class="mb-4">
            <div class="flex items-center justify-between">
                <label class="text-sm font-medium text-gray-700" for="create_ticket">
                    Need to create ticket?
                </label>
                <label class="relative inline-block w-14 h-7 cursor-pointer">
                    <input type="checkbox"
                           id="create_ticket"
                           name="create_ticket"
                           class="sr-only peer">
                    <div class="w-full h-full bg-gray-200 rounded-full peer-checked:bg-blue-600 transition-colors duration-200
                                after:content-[''] after:absolute after:top-0.5 after:left-0.5
                                after:bg-white after:rounded-full after:h-6 after:w-6
                                after:transition-transform peer-checked:after:translate-x-7"></div>
                </label>
            </div>
        </div>

        <!-- Primary Email -->
        <div class="mb-4">
            <label class="block text-sm font-medium text-gray-700 mb-1" for="primary_email">
                Primary Email (LEVELONE)
            </label>
            <input type="email"
                   id="primary_email"
                   name="primary_email"
                   value="levelone@example.com"
                   readonly
                   class="w-full px-3 py-2 bg-gray-50 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
        </div>

        <!-- Client Name -->
        <div class="mb-4">
            <label class="block text-sm font-medium text-gray-700 mb-1" for="client_name">
                Client Name
            </label>
            <input type="text"
                   id="client_name"
                   name="client_name"
                   required
                   placeholder="Enter client name"
                   class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
        </div>

        <!-- Email Fields (Hidden by default) -->
        <div id="emailFields" class="hidden space-y-4">
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1" for="client_email">
                    Client Email
                </label>
                <input type="email"
                       id="client_email"
                       name="client_email"
                       placeholder="Enter client email"
                       class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
            </div>
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1" for="cc_email">
                    CC
                </label>
                <input type="email"
                       id="cc_email"
                       name="cc_email"
                       placeholder="Enter CC email (optional)"
                       class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
            </div>
        </div>

        <!-- Note -->
        <div class="mb-4">
            <label class="block text-sm font-medium text-gray-700 mb-1" for="note">
                Note
            </label>
            <textarea id="note"
                      name="note"
                      rows="4"
                      required
                      placeholder="Enter note about the query"
                      class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500"></textarea>
        </div>

        <!-- Submit Button -->
        <button type="submit"
                id="newQuerySubmitBtn"
                class="w-full px-4 py-2 text-white bg-blue-600 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-colors">
            Save
        </button>
    </form>
</div>

                <!-- Existing Query Form (Initially Hidden) -->
<div id="existingQuerySection" class="query-section" style="display: none; margin-top: 20px;">
    <h5>Existing Query</h5>
    <form id="existingQueryForm" method="post" action="">
        {% csrf_token %}
<div class="mb-4">
    <label for="ticket-id" class="block text-sm font-medium text-gray-700 mb-1">
        Ticket ID
    </label>
    <div class="flex space-x-2">
        <input type="text"
               id="ticket-id"
               name="ticket_id"
               class="flex-1 px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500"
               placeholder="Enter ticket ID">
        <button type="button"
                id="search-ticket"
                class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
            Search
        </button>
    </div>
</div>

        <!-- Ticket details section (Initially hidden) -->
        <div id="ticket-details" style="display: none; margin-top: 20px;">
            <h5>Ticket Details</h5>
            <div class="mb-3">
                <label for="subject" class="form-label">Subject</label>
                <input type="text" class="form-control" id="subject" name="subject">
            </div>
            <div class="mb-3">
                <label for="assigned-to" class="form-label">Assigned To</label>
                <select class="form-control" id="assigned-to" name="assigned_to">
                    <!-- Dynamic options for users -->
                </select>
            </div>

            <div class="mb-3">
                <label for="priority" class="form-label">Priority</label>
                <select class="form-control" id="priority" name="priority">
                    <option value="low">Low</option>
                    <option value="medium">Medium</option>
                    <option value="high">High</option>
                    <option value="urgent">Urgent</option>
                </select>
            </div>

            <!-- Important: change the name to match 'client_call_note' -->
            <div class="mb-3">
                <label for="client_call_note" class="form-label">Note</label>
                <textarea class="form-control" id="client_call_note" name="client_call_note" rows="4" placeholder="Enter note about the ticket"></textarea>
            </div>

            <button type="submit" class="btn btn-success">Update Ticket</button>
        </div>
    </form>
</div>
            </div>
        </div>
    </div>
</div>

<br><br>
<!-- Call Details Table -->
<div class="relative max-w-full mx-auto bg-white p-6 shadow-lg rounded-lg overflow-x-auto my-2">
    <h1 class="text-2xl font-bold mb-6">Call Details</h1>
    <table class="w-full text-sm text-left rtl:text-right border-collapse">
        <thead class="bg-gray-200 text-xs uppercase text-center">
            <tr>
                <th scope="col" class="px-6 py-3 border">
                    Client name
                </th>
                <th scope="col" class="px-6 py-3 border">
                    Client email
                </th>
                <th scope="col" class="px-6 py-3 border">
                    Call Duration
                </th>
                <th scope="col" class="px-6 py-3 border">
                    Ticket Created
                </th>
                <th scope="col" class="px-6 py-3 border">
                    Note
                </th>
            </tr>
        </thead>
        <tbody id="newQueriesBody">
            <!-- Dynamically populated content -->
        </tbody>
    </table>
</div>
</div>

<!-- Right Sidebar -->
<div class="fixed top-20 right-0 overflow-auto h-3/4 bg-white text-gray-700 transform translate-x-full hover:translate-x-0 transition-transform duration-300 z-40"
     id="rightSidebar">
    <div class="p-1">
        <div class="max-w-4xl mx-auto overflow-auto h-full rounded shadow-lg">
            <!-- Dashboard Card -->
            <div class="bg-white shadow-xl rounded-lg h-full">
                <!-- Chart and Stats Section -->
                <div class="grid grid-cols-1 md:grid-cols-1 gap-4 p-2">
                    <!-- Bar Chart Section -->
                    <div class="bg-gray-50 p-2 rounded-lg shadow-lg">
                        <h3 class="text-lg font-semibold mb-4">Today's Status</h3>
                        <canvas id="barChart"></canvas>
                    </div>

                    <!-- Summary Section -->
                    <div class="bg-gray-100 p-6">
                        <div class="flex justify-between items-center">
                            <div>
                                <span class="font-semibold text-gray-600">Total Tickets Today</span>
                                <p class="text-xl font-bold text-green-600">{{ todays_tickets }}</p>
                            </div>
                            <div>
                                <span class="font-semibold text-gray-600">Total Call Time</span>
                                <p class="text-xl font-bold text-blue-600">{{ call_duration }}</p>
                            </div>
                        </div>
                    </div>

                    <!-- Pie Chart Section -->
                    <div class="bg-gray-50 p-2 rounded-lg shadow-lg">
                        <h3 class="text-lg font-semibold mb-4">Overall Tickets</h3>
                        <canvas id="pieChart"></canvas>
                    </div>

                    <table class="w-full border-collapse border border-gray-300 text-left">
                        <tbody id="dataTable" class="bg-white"></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
</div>


</div>
</div>




<!-- Bootstrap JS (including Popper.js) -->
    <!-- Include Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // Get CSRF token
    const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;

    // Dropdown functionality
    function setupDropdowns() {
        const dropdownButtons = document.querySelectorAll('.dropdown-toggle');

        dropdownButtons.forEach(button => {
            button.addEventListener('click', function(e) {
                e.stopPropagation();

                // Close all other dropdowns
                document.querySelectorAll('.dropdown-menu').forEach(menu => {
                    if (menu !== this.nextElementSibling) {
                        menu.classList.add('hidden');
                    }
                });

                // Toggle current dropdown
                const dropdownMenu = this.nextElementSibling;

                // If menu is currently hidden, calculate position before showing
                if (dropdownMenu.classList.contains('hidden')) {
                    // Reset position classes before calculations
                    dropdownMenu.classList.remove('bottom-full', 'top-full');
                    dropdownMenu.style.removeProperty('margin-top');
                    dropdownMenu.style.removeProperty('margin-bottom');

                    // Show temporarily to calculate height
                    dropdownMenu.classList.remove('hidden');

                    const buttonRect = button.getBoundingClientRect();
                    const menuRect = dropdownMenu.getBoundingClientRect();
                    const spaceBelow = window.innerHeight - buttonRect.bottom;
                    const spaceAbove = buttonRect.top;

                    // Hide again for toggle
                    dropdownMenu.classList.add('hidden');

                    if (spaceBelow < menuRect.height && spaceAbove > menuRect.height) {
                        // Position above if more space above than below
                        dropdownMenu.classList.add('bottom-full');
                        dropdownMenu.style.marginBottom = '0.5rem';
                    } else {
                        // Position below
                        dropdownMenu.classList.add('top-full');
                        dropdownMenu.style.marginTop = '0.5rem';
                    }
                }

                // Toggle visibility
                dropdownMenu.classList.toggle('hidden');
            });
        });

        // Close dropdowns when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.dropdown')) {
                document.querySelectorAll('.dropdown-menu').forEach(menu => {
                    menu.classList.add('hidden');
                });
            }
        });
    }

    function getStatusAbbreviation(status) {
        const status_map = {
            'waiting_on_customer': 'WOC',
            'initial_response': 'IR',
            'on_hold': 'OH'
        };
        // Match your filter's behavior: return from map if exists, otherwise return title case
        return status_map[status.toLowerCase()] || status.charAt(0).toUpperCase() + status.slice(1).toLowerCase();
    }

    // Status change functionality
    function setupStatusChange() {
        document.querySelectorAll('.change-status').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();

                const ticketId = this.dataset.ticketId;
                const newStatus = this.dataset.newStatus;
                const dropdownMenu = this.closest('.dropdown-menu');

                // Hide dropdown
                dropdownMenu.classList.add('hidden');

                // Make API call
                fetch('/update_ticket_status/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({
                        ticket_id: ticketId,
                        new_status: newStatus
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Update status cell
                        const ticketRow = document.querySelector(`tr[data-ticket-id="${ticketId}"]`);
                        const statusCell = ticketRow.querySelector('td[data-status]');
                        if (statusCell) {
                            // Update status cell content and attributes
                            const abbreviatedStatus = getStatusAbbreviation(newStatus);
                            statusCell.textContent = abbreviatedStatus;
                            statusCell.setAttribute('data-status', newStatus.toLowerCase());
                        }

                        // Store the status change time in localStorage
                        const statusChangeTime = data.status_changed;
                        localStorage.setItem(`ticket_${ticketId}_status_changed`, statusChangeTime);

                        // Only reset the color/classes of individual time cell
                        const individualTimeCell = ticketRow.querySelector('.time-column.individual-time');
                        if (individualTimeCell) {
                            // Remove only the exceeded class, don't touch the content
                            individualTimeCell.classList.remove('exceeded');

                            // Optional: Add a brief highlight effect to show the status change
                            individualTimeCell.style.transition = 'background-color 0.3s';
                            individualTimeCell.style.backgroundColor = 'rgba(255, 255, 0, 0.2)';
                            setTimeout(() => {
                                individualTimeCell.style.backgroundColor = '';
                            }, 500);
                        }

                        // Handle closed/resolved tickets
                        if (['closed', 'resolved'].includes(newStatus)) {
                            ticketRow.style.display = 'none';
                            const expandedRow = document.getElementById(`expanded-row-${ticketId}`);
                            if (expandedRow) {
                                expandedRow.style.display = 'none';
                            }
                        }

                        // Show success toast notification and reload
                        Swal.fire({
                            title: 'Success!',
                            text: 'Status updated successfully!',
                            icon: 'success',
                            toast: true,
                            position: 'top-end',
                            showConfirmButton: false,
                            timer: 3000,
                            timerProgressBar: true,
                            customClass: {
                                popup: 'bg-white rounded-lg shadow-xl p-4',
                                title: 'text-lg font-semibold text-gray-800',
                                content: 'text-gray-600'
                            }
                        }).then(() => {
                            window.location.reload();
                        });
                    } else {
                        // Show error toast
                        Swal.fire({
                            title: 'Error!',
                            text: data.message || 'Failed to update status.',
                            icon: 'error',
                            toast: true,
                            position: 'top-end',
                            showConfirmButton: false,
                            timer: 3000,
                            customClass: {
                                popup: 'bg-white rounded-lg shadow-xl',
                                title: 'text-lg font-semibold text-red-600',
                                content: 'text-gray-600'
                            }
                        });
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    Swal.fire({
                        title: 'Error!',
                        text: 'An error occurred while updating the status.',
                        icon: 'error',
                        toast: true,
                        position: 'top-end',
                        showConfirmButton: false,
                        timer: 3000,
                        customClass: {
                            popup: 'bg-white rounded-lg shadow-xl'
                        }
                    });
                });
            });
        });
    }

    // Timer update functionality
    function updateTicketDisplay(ticketId) {
        const ticketRow = document.querySelector(`tr[data-ticket-id="${ticketId}"]`);
        if (!ticketRow) return;

        const totalTimeCell = ticketRow.querySelector('.time-column.total-time');
        const individualTimeCell = ticketRow.querySelector('.time-column.individual-time');
        const statusChanged = localStorage.getItem(`ticket_${ticketId}_status_changed`);

        if (ticketRow.classList.contains('priority-alert')) {
            const priorityClass = `priority-${ticketRow.dataset.priority}`;
            if (totalTimeCell) {
                totalTimeCell.classList.add(priorityClass);
            }
            if (individualTimeCell && !statusChanged) {
                individualTimeCell.classList.add('exceeded');
            }
        }
    }

    // Cleanup old status changes
    function cleanupOldStatusChanges() {
        const keys = Object.keys(localStorage);
        const now = new Date();
        keys.forEach(key => {
            if (key.startsWith('ticket_') && key.endsWith('_status_changed')) {
                const timestamp = localStorage.getItem(key);
                const changeTime = new Date(timestamp);
                if (now - changeTime > 24 * 60 * 60 * 1000) {
                    localStorage.removeItem(key);
                }
            }
        });
    }

    // Initialize all functionalities
    setupDropdowns();
    setupStatusChange();

    // Set up periodic updates
    document.querySelectorAll('[data-ticket-id]').forEach(row => {
        updateTicketDisplay(row.dataset.ticketId);
    });

    setInterval(() => {
        document.querySelectorAll('[data-ticket-id]').forEach(row => {
            updateTicketDisplay(row.dataset.ticketId);
        });
    }, 30000);

    setInterval(cleanupOldStatusChanges, 60 * 60 * 1000);
    cleanupOldStatusChanges();
});
</script>

<script>
document.addEventListener('DOMContentLoaded', function () {
    const postCallForm = document.querySelector('form');

    if (postCallForm) {
        postCallForm.addEventListener('submit', function (e) {
            e.preventDefault(); // Prevent the form from submitting normally

            const formData = new FormData(this);
            const actionUrl = this.getAttribute('action');

            fetch(actionUrl, {
                method: 'POST',
                body: formData,
                headers: {
                    'X-CSRFToken': formData.get('csrfmiddlewaretoken')
                }
            })
            .then(response => {
                if (response.ok) {
                    // After successful form submission, redirect or update UI
                    window.location.href = '/dashboard/';  // Redirect to dashboard
                } else {
                    console.error('Error saving post-call details.');
                }
            })
            .catch(error => {
                console.error('Error:', error);
            });
        });
    }
});

</script>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // Initialize variables and constants
    let timers = {};
    const localStorageKey = 'ticketTimers';
    const breakToggle = document.getElementById('breakToggle');
    const breakStatus = document.getElementById('breakStatus');
    const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;
    let activeTicketId = null;
    let activeCallTicketId = null;

    // Add CSS for disabled button styling
    const style = document.createElement('style');
    style.textContent = `
        .start-button.started-by-call {
            opacity: 0.7;
            cursor: not-allowed !important;
            background-color: #6c757d !important;
            border-color: #6c757d !important;
            pointer-events: all !important;
        }
        .start-button.blocked {
            opacity: 0.7;
            cursor: not-allowed !important;
            background-color: #6c757d !important;
            border-color: #6c757d !important;
            pointer-events: all !important;
        }
        .call-action-form button.blocked {
            opacity: 0.7;
            cursor: not-allowed !important;
            pointer-events: all !important;
        }
        /* Hover states */
        .start-button.blocked:hover,
        .start-button.started-by-call:hover,
        .call-action-form button.blocked:hover {
            opacity: 0.7 !important;
            cursor: not-allowed !important;
            background-color: #6c757d !important;
            border-color: #6c757d !important;
        }
    `;
    document.head.appendChild(style);


    // Utility functions
    function formatTime(seconds) {
        const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
        const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
        const s = Math.floor(seconds % 60).toString().padStart(2, '0');
        return `${h}:${m}:${s}`;
    }

    function showModal(modalId) {
        const modal = document.getElementById(modalId);
        modal.classList.remove('hidden');
    }

    function hideModal(modalId) {
        const modal = document.getElementById(modalId);
        modal.classList.add('hidden');
    }

    function getCurrentDateTime() {
        const now = new Date();
        return now.getUTCFullYear() + '-' +
               String(now.getUTCMonth() + 1).padStart(2, '0') + '-' +
               String(now.getUTCDate()).padStart(2, '0') + ' ' +
               String(now.getUTCHours()).padStart(2, '0') + ':' +
               String(now.getUTCMinutes()).padStart(2, '0') + ':' +
               String(now.getUTCSeconds()).padStart(2, '0');
    }

    function blockOtherTicketButtons(currentTicketId) {
        document.querySelectorAll('.start-button').forEach(button => {
            const ticketId = button.dataset.ticketId;
            if (ticketId !== currentTicketId) {
                button.classList.add('blocked');
                button.disabled = true;
            }
        });
    }

    function unblockAllTicketButtons() {
        document.querySelectorAll('.start-button').forEach(button => {
            button.classList.remove('blocked');
            button.disabled = false;
        });
    }

    function blockAllTicketInteractions(exceptTicketId) {
        document.querySelectorAll('.start-button, .call-action-form button').forEach(button => {
            const ticketId = button.closest('[data-ticket-id]')?.dataset.ticketId;
            if (ticketId !== exceptTicketId) {
                button.classList.add('blocked');
                button.disabled = true;
            }
        });
    }

    function unblockAllTicketInteractions() {
        document.querySelectorAll('.start-button, .call-action-form button').forEach(button => {
            button.classList.remove('blocked');
            button.disabled = false;
        });
        // Reapply blocks if there's an active timer
        if (activeTicketId && !activeCallTicketId) {
            blockOtherTicketButtons(activeTicketId);
        }
    }

    function pauseFrontendTimer(ticketId) {
        if (timers[ticketId] && timers[ticketId].interval) {
            clearInterval(timers[ticketId].interval);

            timers[ticketId].isPausedByCall = true;
            timers[ticketId].pausedAt = {
                total: timers[ticketId].currentTotal,
                individual: timers[ticketId].currentIndividual,
                time: Date.now(),
                pausedDateTime: getCurrentDateTime()
            };

            const totalTimerElement = document.getElementById('timer-' + ticketId);
            const individualTimerElement = document.getElementById('individual-timer-' + ticketId);

            if (totalTimerElement) {
                totalTimerElement.textContent = formatTime(timers[ticketId].currentTotal);
            }
            if (individualTimerElement) {
                individualTimerElement.textContent = formatTime(timers[ticketId].currentIndividual);
            }

            localStorage.setItem(localStorageKey, JSON.stringify(timers));
        }
    }

    function resumeFrontendTimer(ticketId) {
        if (timers[ticketId] && timers[ticketId].isPausedByCall) {
            const pausedValues = timers[ticketId].pausedAt;
            if (pausedValues) {
                startFrontendTimers(
                    ticketId,
                    pausedValues.total,
                    pausedValues.individual,
                    Date.now(),
                    timers[ticketId].startedByCall // Preserve the startedByCall state
                );
                delete timers[ticketId].isPausedByCall;
                delete timers[ticketId].pausedAt;
            }
        }
    }

    function startFrontendTimers(ticketId, totalAccumulatedTime, individualAccumulatedTime, startTime, startedByCall = false) {
        const totalTimerElement = document.getElementById('timer-' + ticketId);
        const individualTimerElement = document.getElementById('individual-timer-' + ticketId);
        const startButton = document.querySelector(`.start-button[data-ticket-id="${ticketId}"]`);

        if (!totalTimerElement || !individualTimerElement) return;

        if (timers[ticketId] && timers[ticketId].interval) {
            clearInterval(timers[ticketId].interval);
        }

        // Update button state for call-started timers
        if (startButton && startedByCall) {
            startButton.textContent = 'Stop';
            startButton.classList.add('started-by-call');
            startButton.disabled = true;
        }

        timers[ticketId] = {
            totalAccumulatedTime: totalAccumulatedTime,
            individualAccumulatedTime: individualAccumulatedTime,
            startTime: startTime,
            isActive: true,
            currentTotal: totalAccumulatedTime,
            currentIndividual: individualAccumulatedTime,
            startDateTime: getCurrentDateTime(),
            startedByCall: startedByCall // Track if timer was started by call
        };

        totalTimerElement.textContent = formatTime(totalAccumulatedTime);
        individualTimerElement.textContent = formatTime(individualAccumulatedTime);

        timers[ticketId].interval = setInterval(() => {
            const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
            const totalTime = totalAccumulatedTime + elapsedTime;
            const individualTime = individualAccumulatedTime + elapsedTime;

            timers[ticketId].currentTotal = totalTime;
            timers[ticketId].currentIndividual = individualTime;

            totalTimerElement.textContent = formatTime(totalTime);
            individualTimerElement.textContent = formatTime(individualTime);
        }, 1000);

        if (timers[ticketId].isPausedByCall) {
            delete timers[ticketId].isPausedByCall;
        }

        localStorage.setItem(localStorageKey, JSON.stringify(timers));
    }

    function stopFrontendTimers(ticketId) {
        if (timers[ticketId] && timers[ticketId].interval) {
            clearInterval(timers[ticketId].interval);

            timers[ticketId].totalAccumulatedTime = timers[ticketId].currentTotal;
            timers[ticketId].individualAccumulatedTime = timers[ticketId].currentIndividual;
            timers[ticketId].isActive = false;
            timers[ticketId].stopDateTime = getCurrentDateTime();

            const totalTimerElement = document.getElementById('timer-' + ticketId);
            const individualTimerElement = document.getElementById('individual-timer-' + ticketId);
            const startButton = document.querySelector(`.start-button[data-ticket-id="${ticketId}"]`);

            if (totalTimerElement) {
                totalTimerElement.textContent = formatTime(timers[ticketId].totalAccumulatedTime);
            }
            if (individualTimerElement) {
                individualTimerElement.textContent = formatTime(timers[ticketId].individualAccumulatedTime);
            }

            // Reset button state if it was started by call
            if (startButton && timers[ticketId].startedByCall) {
                startButton.classList.remove('started-by-call');
                startButton.disabled = false;
            }

            delete timers[ticketId];
            localStorage.setItem(localStorageKey, JSON.stringify(timers));
        }
    }

    function handleBreakToggle(isBreak) {
        // First make the server request to check if break is allowed
        fetch("{% url 'toggle_break_status' %}", {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({})
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'error') {
                // Revert the checkbox if there's an error
                breakToggle.checked = !isBreak;

                // Show error message using SweetAlert2
                Swal.fire({
                    title: 'Break Not Available',
                    text: data.message,
                    icon: 'warning',
                    confirmButtonText: 'Ok',
                    confirmButtonColor: '#3085d6'
                });
                return;
            }

            // If successful, proceed with existing break toggle logic
            // Update text and classes
            const breakStatus = document.getElementById('breakStatus');
            breakStatus.textContent = isBreak ? 'On Break' : 'Active';

            // Remove existing classes and add the appropriate one
            breakStatus.classList.remove('active', 'break');
            breakStatus.classList.add(isBreak ? 'break' : 'active');

            // Update the toggle color
            const modernSlider = document.querySelector('.modern-slider');
            if (modernSlider) {
                modernSlider.style.backgroundColor = isBreak ? '#dc3545' : '#28a745';
            }

            // Handle all active timers
            document.querySelectorAll('.start-button').forEach(button => {
                const ticketId = button.dataset.ticketId;

                if (isBreak && timers[ticketId] && timers[ticketId].isActive) {
                    clearInterval(timers[ticketId].interval);
                    timers[ticketId].isPausedForBreak = true;
                    timers[ticketId].pausedAt = {
                        total: timers[ticketId].currentTotal,
                        individual: timers[ticketId].currentIndividual,
                        time: Date.now(),
                        pausedDateTime: getCurrentDateTime()
                    };

                    const totalTimerElement = document.getElementById('timer-' + ticketId);
                    const individualTimerElement = document.getElementById('individual-timer-' + ticketId);

                    if (totalTimerElement) {
                        totalTimerElement.textContent = formatTime(timers[ticketId].currentTotal);
                    }
                    if (individualTimerElement) {
                        individualTimerElement.textContent = formatTime(timers[ticketId].currentIndividual);
                    }
                } else if (!isBreak && timers[ticketId] && timers[ticketId].isPausedForBreak) {
                    const pausedValues = timers[ticketId].pausedAt;
                    if (pausedValues) {
                        startFrontendTimers(
                            ticketId,
                            pausedValues.total,
                            pausedValues.individual,
                            Date.now(),
                            timers[ticketId].startedByCall
                        );
                        timers[ticketId].isPausedForBreak = false;
                        delete timers[ticketId].pausedAt;
                    }
                }
            });

            // Show notification if others can take breaks
            if (data.message) {
                Swal.fire({
                    title: 'Break Available',
                    text: data.message,
                    icon: 'info',
                    confirmButtonText: 'Ok',
                    confirmButtonColor: '#3085d6'
                });
            }
        })
        .catch(error => {
            console.error('Error:', error);
            // Revert the checkbox state on error
            breakToggle.checked = !isBreak;
        });
    }

    // Call Action Form Handler
    document.querySelectorAll('.call-action-form').forEach(function(form) {
        form.addEventListener('submit', function(e) {
            e.preventDefault();

            const formData = new FormData(this);
            const actionUrl = this.getAttribute('action');
            const ticketId = this.dataset.ticketId;

            fetch(actionUrl, {
                method: 'POST',
                body: formData,
                headers: {
                    'X-CSRFToken': formData.get('csrfmiddlewaretoken'),
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    if (formData.get('action') === 'start_call') {
                        // Store whether the timer was started by this call
                        form.dataset.timerStartedByCall = data.timer_started_by_call;
                        activeCallTicketId = ticketId;
                        blockAllTicketInteractions(ticketId);

                        // Get the start button and handle timer
                        const startButton = document.querySelector(`.start-button[data-ticket-id="${ticketId}"]`);
                        if (startButton && data.timer_started_by_call) {
                            // Get the timer elements
                            const totalTimerElement = document.getElementById('timer-' + ticketId);
                            const individualTimerElement = document.getElementById('individual-timer-' + ticketId);

                            // Parse current display values if they exist
                            let totalTime = 0;
                            let individualTime = 0;

                            if (totalTimerElement && individualTimerElement) {
                                // Convert HH:MM:SS to seconds
                                const parseTimeToSeconds = (timeStr) => {
                                    const [hours, minutes, seconds] = timeStr.split(':').map(Number);
                                    return hours * 3600 + minutes * 60 + seconds;
                                };

                                // Get current display values
                                totalTime = parseTimeToSeconds(totalTimerElement.textContent);
                                individualTime = parseTimeToSeconds(individualTimerElement.textContent);
                            }

                            // Check for existing timer in memory
                            if (timers[ticketId]) {
                                totalTime = Math.max(totalTime, timers[ticketId].currentTotal || 0);
                                individualTime = Math.max(individualTime, timers[ticketId].currentIndividual || 0);
                            } else {
                                // Check localStorage for existing timer
                                const savedTimers = JSON.parse(localStorage.getItem(localStorageKey) || '{}');
                                if (savedTimers[ticketId]) {
                                    totalTime = Math.max(totalTime, savedTimers[ticketId].currentTotal || 0);
                                    individualTime = Math.max(individualTime, savedTimers[ticketId].currentIndividual || 0);
                                }
                            }

                            // Use server values as fallback
                            totalTime = Math.max(totalTime, data.time_spent_seconds || 0);
                            individualTime = Math.max(individualTime, data.individual_time_spent_seconds || 0);

                            // Start timer with preserved values
                            startFrontendTimers(
                                ticketId,
                                totalTime,
                                individualTime,
                                Date.now(),
                                true // Indicate this timer was started by call
                            );
                            startButton.textContent = 'Stop';
                        }

                        // Update UI and pause timers for paused tickets
                        if (data.paused_tickets) {
                            data.paused_tickets.forEach(pausedId => {
                                const pausedButton = document.querySelector(`.start-button[data-ticket-id="${pausedId}"]`);
                                if (pausedButton) {
                                    pausedButton.textContent = 'Paused';
                                    pausedButton.classList.add('paused-by-call');
                                    pauseFrontendTimer(pausedId);
                                }
                            });
                        }

                        // Update call button
                        const button = this.querySelector('button');
                        button.textContent = 'End Call';
                        button.classList.remove('btn-warning');
                        button.classList.add('btn-danger');
                        this.querySelector('input[name="action"]').value = 'end_call';
                    } else if (formData.get('action') === 'end_call') {
                        // Show the post-call modal
                        showModal('postCallModal');

                        // Populate modal fields
                        document.getElementById('modal-ticket-id').value = data.ticket_id;
                        document.getElementById('modal-ticket-id-display').value = data.ticket_display_id;
                        document.getElementById('modal-subject').value = data.subject;
                        document.getElementById('modal-status').value = data.current_status;
                    }
                }
            })
            .catch(error => console.error('Error:', error));
        });
    });

    // Post Call Form Handler
    document.getElementById('postCallForm').addEventListener('submit', function (e) {
        e.preventDefault();

        const formData = new FormData(this);
        const ticketId = document.getElementById('modal-ticket-id').value;

        if (ticketId) {
            fetch(`/ticket/post_call_details/${ticketId}/`, {
                method: 'POST',
                body: formData,
                headers: {
                    'X-CSRFToken': formData.get('csrfmiddlewaretoken'),
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    activeCallTicketId = null;
                    unblockAllTicketInteractions();
                    // Resume paused timers
                    if (data.resumed_tickets) {
                        data.resumed_tickets.forEach(resumedId => {
                            const resumedButton = document.querySelector(`.start-button[data-ticket-id="${resumedId}"]`);
                            if (resumedButton) {
                                resumedButton.textContent = 'Stop';
                                resumedButton.classList.remove('paused-by-call');
                                resumeFrontendTimer(resumedId);
                            }
                        });
                    }

                    // Find the call form to check if timer should be stopped
                    const callForm = document.querySelector(`.call-action-form[data-ticket-id="${ticketId}"]`);
                    const timerStartedByCall = callForm ? callForm.dataset.timerStartedByCall === 'true' : false;

                    // Handle the timer that was started by the call
                    if (timerStartedByCall) {
                        const startButton = document.querySelector(`.start-button[data-ticket-id="${ticketId}"]`);
                        if (startButton) {
                            startButton.textContent = 'Start';
                            startButton.classList.remove('started-by-call');
                            startButton.disabled = false;
                            stopFrontendTimers(ticketId);
                        }
                    }

                    // Reset call button state
                    if (callForm) {
                        const callButton = callForm.querySelector('button');
                        callButton.textContent = 'Start Call';
                        callButton.classList.remove('btn-danger');
                        callButton.classList.add('btn-warning');
                        callForm.querySelector('input[name="action"]').value = 'start_call';
                        callForm.dataset.timerStartedByCall = 'false';
                    }

                    // Close modal and reload
                    hideModal('postCallModal');
                    location.reload();
                }
            })
            .catch(error => console.error('Error:', error));
        }
    });

    // Modal close handlers
    const closeButton = document.querySelector('#postCallModal .btn-secondary');
    const closeIcon = document.querySelector('#postCallModal .close');

    if (closeButton) {
        closeButton.addEventListener('click', function() {
            hideModal('postCallModal');
        });
    }

    if (closeIcon) {
        closeIcon.addEventListener('click', function() {
            hideModal('postCallModal');
        });
    }

    // Enhanced Start/Stop button click handler with call-started timer blocking
    document.querySelectorAll('.start-button').forEach(button => {
        button.addEventListener('click', function(e) {
            e.preventDefault();

            if (breakToggle.checked) return;

            const ticketId = this.dataset.ticketId;

            // Block interaction if timer was started by call
            if (timers[ticketId] && timers[ticketId].startedByCall) {
                alert('This timer was started by a call and can only be stopped by ending the call.');
                return;
            }

            // Block if there's an active call on another ticket
            if (activeCallTicketId && activeCallTicketId !== ticketId) {
                alert('Please end the current call before starting a new timer.');
                return;
            }

            const action = this.textContent.trim() === 'Start' ? 'start' : 'stop';

            fetch(`/tickets/${ticketId}/${action}/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken,
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    this.textContent = action === 'start' ? 'Stop' : 'Start';

                    if (action === 'start') {
                        activeTicketId = ticketId;
                        blockOtherTicketButtons(ticketId);
                        startFrontendTimers(
                            ticketId,
                            data.time_spent_seconds,
                            data.individual_time_spent_seconds,
                            Date.now(),
                            false
                        );
                    } else {
                        activeTicketId = null;
                        unblockAllTicketButtons();
                        stopFrontendTimers(ticketId);
                    }
                } else {
                    alert('Failed to update ticket activity');
                }
            })
            .catch(error => console.error('Error:', error));
        });
    });

    // Break toggle event listener
    if (breakToggle) {
        breakToggle.addEventListener('change', function() {
            handleBreakToggle(this.checked);
        });
    }

    // Initialize active timers from localStorage with call-started state preservation
    const savedTimers = JSON.parse(localStorage.getItem(localStorageKey) || '{}');
    Object.entries(savedTimers).forEach(([ticketId, timerData]) => {
        if (timerData.isActive) {
            startFrontendTimers(
                ticketId,
                timerData.totalAccumulatedTime,
                timerData.individualAccumulatedTime,
                timerData.startTime,
                timerData.startedByCall // Preserve the call-started state
            );
        }
    });
});
</script>

<script>
document.addEventListener('DOMContentLoaded', function () {
    // Handle Note form submission via AJAX
    document.getElementById('noteForm').addEventListener('submit', function(e) {
        e.preventDefault();  // Prevent default form submission

        const formData = new FormData(this);

        fetch('{% url "save_call_note" %}', {
            method: 'POST',
            body: formData,
            headers: {
                'X-CSRFToken': formData.get('csrfmiddlewaretoken'),
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                alert(data.message);  // Show success message
                $('#clientCallModal').modal('hide');  // Close modal
            } else {
                alert(data.message);  // Show error message
            }
        })
        .catch(error => console.error('Error:', error));
    });
});
</script>

<script>
// Global variables
let callStartTime = null;
const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;

// Modal Control Functions
function openModal() {
    const modal = document.getElementById('clientCallModal');
    if (modal) {
        modal.classList.remove('hidden');
        document.body.style.overflow = 'hidden';
        startNewCall();
    }
}

function closeModal() {
    const modal = document.getElementById('clientCallModal');
    if (modal) {
        modal.classList.add('hidden');
        document.body.style.overflow = 'auto';
        const newQuerySection = document.getElementById('newQuerySection');
        const existingQuerySection = document.getElementById('existingQuerySection');
        if (newQuerySection) newQuerySection.style.display = 'none';
        if (existingQuerySection) existingQuerySection.style.display = 'none';

        // Reset circles
        document.querySelectorAll('.query-circle').forEach(circle => {
            circle.classList.remove('bg-blue-500');
        });

        endNewCall();
    }
}

function showSection(type) {
    const newQuerySection = document.getElementById('newQuerySection');
    const existingQuerySection = document.getElementById('existingQuerySection');

    // Reset all circles
    document.querySelectorAll('.query-circle').forEach(circle => {
        circle.classList.remove('bg-blue-500');
    });

    // Get clicked button's circle and activate it
    const clickedButton = event.currentTarget;
    const circle = clickedButton.querySelector('.query-circle');
    circle.classList.add('bg-blue-500');

    // Show/hide sections
    if (newQuerySection) newQuerySection.style.display = type === 'new' ? 'block' : 'none';
    if (existingQuerySection) existingQuerySection.style.display = type === 'existing' ? 'block' : 'none';
}

// Timer Functions
function startNewCall() {
    fetch('/start-new-call/', {
        method: 'POST',
        headers: {
            'X-CSRFToken': csrfToken,
            'Content-Type': 'application/json'
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            callStartTime = new Date(data.call_start_time);
            console.log('Call started successfully');
        }
    })
    .catch(error => console.error('Error starting call:', error));
}

function endNewCall() {
    if (!callStartTime) return;

    fetch('/end-new-call/', {
        method: 'POST',
        headers: {
            'X-CSRFToken': csrfToken,
            'Content-Type': 'application/json'
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            callStartTime = null;
            console.log('Call ended successfully');
        }
    })
    .catch(error => console.error('Error ending call:', error));
}

// Table Functions
function loadCallQueries() {
    fetch('/get-call-queries/')
        .then(response => response.json())
        .then(data => {
            const tbody = document.getElementById('newQueriesBody');
            tbody.innerHTML = '';

            data.new_queries.forEach(query => {
                const row = document.createElement('tr');
                row.className = "border-b border-gray-200 hover:bg-gray-100";
                row.innerHTML = `
                    <th scope="row" class="px-6 py-4 w-4 font-medium whitespace-nowrap border">
                        ${query.client_name}
                    </th>
                    <td class="px-6 py-4 w-5 text-center border">
                        ${query.client_email || '-'}
                    </td>
                    <td class="px-6 py-4 w-4 text-center border">
                        ${query.call_duration || '-'}
                    </td>
                    <td class="px-6 py-4 w-4 text-center border">
                        ${query.ticket_created ? '✅' : '❌'}
                    </td>
                    <td class="px-6 py-4 text-center border note-cell">
                        <div class="truncate-text" title="${query.note}">
                            ${query.note}
                        </div>
                    </td>
                `;
                tbody.appendChild(row);
            });
        })
        .catch(error => console.error('Error loading queries:', error));
}

// Main initialization
document.addEventListener('DOMContentLoaded', function() {
    // Initialize elements
    const modal = document.getElementById('clientCallModal');
    const createTicketToggle = document.getElementById('create_ticket');
    const emailFields = document.getElementById('emailFields');
    const searchButton = document.getElementById('search-ticket');

    // Modal event listeners
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') closeModal();
    });

    if (modal) {
        modal.addEventListener('click', function(e) {
            if (e.target === this) closeModal();
        });
    }

    // Create ticket toggle handler
    if (createTicketToggle) {
        createTicketToggle.addEventListener('change', function() {
            // Update the submit button
            const submitBtn = document.getElementById('newQuerySubmitBtn');
            if (submitBtn) {
                submitBtn.textContent = this.checked ? 'Send' : 'Save';
                // Update button colors
                if (this.checked) {
                    submitBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                    submitBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                } else {
                    submitBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                    submitBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');
                }
            }

            // Toggle email fields
            if (emailFields) {
                if (this.checked) {
                    emailFields.classList.remove('hidden');
                    const clientEmailInput = document.getElementById('client_email');
                    if (clientEmailInput) {
                        clientEmailInput.required = true;
                    }
                } else {
                    emailFields.classList.add('hidden');
                    const clientEmailInput = document.getElementById('client_email');
                    if (clientEmailInput) {
                        clientEmailInput.required = false;
                        clientEmailInput.value = '';
                        document.getElementById('cc_email').value = '';
                    }
                }
            }

            // Log state for debugging
            console.log('Toggle state:', this.checked);
            console.log('Email fields visibility:', !emailFields.classList.contains('hidden'));
        });
    }

    // Search ticket handler
    if (searchButton) {
        searchButton.addEventListener('click', function() {
            const ticketId = document.getElementById('ticket-id').value;
            if (!ticketId) {
                alert('Please enter a ticket ID');
                return;
            }

            // Show loading state
            this.disabled = true;
            this.innerHTML = `
                <svg class="animate-spin h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>`;

            fetch(`/tickets/search/${ticketId}/`, {
                method: 'GET',
                headers: { 'X-CSRFToken': csrfToken }
            })
            .then(response => response.json())
            .then(data => {
                this.disabled = false;
                this.textContent = 'Search';

                const ticketDetails = document.getElementById('ticket-details');
                if (data.success) {
                    ticketDetails.style.display = 'block';
                    document.getElementById('subject').value = data.ticket.subject;
                    document.getElementById('priority').value = data.ticket.priority;

                    const assignedToDropdown = document.getElementById('assigned-to');
                    assignedToDropdown.innerHTML = '';
                    data.users.forEach(user => {
                        const option = document.createElement('option');
                        option.value = user.id;
                        option.textContent = user.username;
                        option.selected = user.id == data.ticket.assigned_to;
                        assignedToDropdown.appendChild(option);
                    });

                    document.getElementById('client_call_note').value = data.ticket.note || '';
                } else {
                    alert('Ticket not found');
                    ticketDetails.style.display = 'none';
                }
            })
            .catch(error => {
                console.error('Error:', error);
                this.disabled = false;
                this.textContent = 'Search';
                alert('Error searching for ticket');
            });
        });
    }

    // Form submission handlers
    document.getElementById('newQueryForm')?.addEventListener('submit', async function(e) {
        e.preventDefault();

        try {
            const endCallResponse = await fetch('/end-new-call/', {
                method: 'POST',
                headers: {
                    'X-CSRFToken': csrfToken,
                    'Content-Type': 'application/json'
                }
            }).then(response => response.json());

            if (endCallResponse.status === 'success') {
                const formData = new FormData(this);
                if (endCallResponse.call_duration) {
                    formData.append('call_duration_seconds', endCallResponse.call_duration);
                }

                const saveResponse = await fetch('/save-new-call-query/', {
                    method: 'POST',
                    headers: { 'X-CSRFToken': csrfToken },
                    body: formData
                }).then(response => response.json());

                if (saveResponse.status === 'success') {
                    alert('Call query saved successfully');
                    closeModal();
                    loadCallQueries();
                    window.location.reload();
                } else {
                    throw new Error('Failed to save call query');
                }
            }
        } catch (error) {
            console.error('Error:', error);
            alert('Error saving call query');
        }
    });

    document.getElementById('existingQueryForm')?.addEventListener('submit', async function(e) {
        e.preventDefault();

        try {
            const endCallResponse = await fetch('/end-new-call/', {
                method: 'POST',
                headers: {
                    'X-CSRFToken': csrfToken,
                    'Content-Type': 'application/json'
                }
            }).then(response => response.json());

            const formData = new FormData(this);
            if (endCallResponse.status === 'success' && endCallResponse.call_duration) {
                formData.append('call_duration_seconds', endCallResponse.call_duration);
            }

            const ticketId = document.getElementById('ticket-id').value;
            const updateResponse = await fetch(`/tickets/update/${ticketId}/`, {
                method: 'POST',
                headers: { 'X-CSRFToken': csrfToken },
                body: formData
            }).then(response => response.json());

            if (updateResponse.success) {
                alert('Ticket updated successfully');
                closeModal();
                window.location.reload();
            } else {
                throw new Error('Failed to update ticket');
            }
        } catch (error) {
            console.error('Error:', error);
            alert('Error updating ticket');
        }
    });

    // Initialize the queries table
    loadCallQueries();
});
</script>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // Function to format time
    function formatTime(hours, minutes, seconds) {
        // Handle negative values
        if (hours < 0 || minutes < 0 || seconds < 0) {
            return "00:00:00";
        }
        return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    }

    // Function to update a single timer
    function updateCreatedTimer(timerElement) {
        // Get the created_at time from the data attribute
        let createdAtStr = timerElement.dataset.createdAt;

        // Convert to local timezone
        const createdAt = new Date(createdAtStr);
        const status = timerElement.dataset.status;

        // Don't update timer if ticket is closed or resolved
        if (status === 'closed' || status === 'resolved') {
            return;
        }

        const now = new Date();

        // Ensure proper timezone handling
        const diff = now - createdAt;

        // Prevent negative values
        if (diff < 0) {
            timerElement.textContent = "00:00:00";
            return;
        }

        const hours = Math.floor(diff / (1000 * 60 * 60));
        const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((diff % (1000 * 60)) / 1000);

        timerElement.textContent = formatTime(hours, minutes, seconds);
    }

    // Update all timers
    function updateAllCreatedTimers() {
        const timerElements = document.querySelectorAll('.created-timer-span');
        timerElements.forEach(updateCreatedTimer);
    }

    // Initial update
    updateAllCreatedTimers();

    // Update every second
    setInterval(updateAllCreatedTimers, 1000);
});



// Format large time durations
function formatLongDuration(hours) {
    if (hours >= 24) {
        const days = Math.floor(hours / 24);
        const remainingHours = hours % 24;
        return `${days}d ${String(remainingHours).padStart(2, '0')}:`;
    }
    return String(hours).padStart(2, '0') + ':';
}

// Update the timer update function to handle long durations
function updateCreatedTimer(timerElement) {
    const createdAt = new Date(timerElement.dataset.createdAt + 'Z');
    const status = timerElement.dataset.status;

    if (status === 'closed' || status === 'resolved') {
        return;
    }

    const now = new Date();
    const diff = now - createdAt;

    const hours = Math.floor(diff / (1000 * 60 * 60));
    const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((diff % (1000 * 60)) / 1000);

    const formattedTime = formatLongDuration(hours) +
        String(minutes).padStart(2, '0') + ':' +
        String(seconds).padStart(2, '0');

    timerElement.textContent = formattedTime;

    // Add warning class for long-running tickets
    if (hours >= 24) {
        timerElement.classList.add('long-running');
    }
}
</script>




{% block extra_js %}
<!-- Order matters - load these in sequence -->
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
<script>
    // Ensure CSRF token is available globally
    window.CSRF_TOKEN = "{{ csrf_token }}";
</script>
<script src="{% static 'employee/js/notifications.js' %}"></script>
<script>
    // Initialize after DOM loads
    document.addEventListener('DOMContentLoaded', function() {
        if (typeof notificationManager === 'undefined') {
            window.notificationManager = new NotificationManager();
        }
        window.notificationManager.init();
    });
</script>
{% endblock %}

<script>
function handleLogout(event) {
    event.preventDefault();

    // Make an AJAX call to the logout endpoint
    fetch('/logout', {
        method: 'GET',
        headers: {
            'X-Requested-With': 'XMLHttpRequest',
        },
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'error') {
            // Create a formatted list of tickets grouped by status
            let ticketList = Object.entries(data.tickets).map(([status, tickets]) => {
                const ticketsInStatus = tickets.map(ticket =>
                    `   • ${ticket.ticket_id}: ${ticket.subject}`
                ).join('\n');
                return `${status} Tickets:\n${ticketsInStatus}`;
            }).join('\n\n');

            // Show the alert with Sweetalert2
            Swal.fire({
                title: 'Cannot Logout',
                html: `<div class="alert alert-warning">
                    <p>You have the following unresolved tickets that need to be assigned to another agent:</p>
                    <pre class="text-left">${ticketList}</pre>
                    <p class="mt-3">Please assign these tickets to another agent before logging out.</p>
                </div>`,
                icon: 'warning',
                confirmButtonText: 'OK',
                customClass: {
                    container: 'my-swal',
                    popup: 'my-swal-popup'
                }
            });
        } else if (data.status === 'success') {
            // Show a success message and redirect
            Swal.fire({
                title: 'Success',
                text: 'You have been successfully logged out.',
                icon: 'success',
                timer: 1500,
                showConfirmButton: false
            }).then(() => {
                window.location.href = '/login';
            });
        }
    })
    .catch(error => {
        console.error('Error:', error);
        // If there's an error, redirect to login page anyway
        window.location.href = '/login';
    });
}

// Add event listener to logout link/button
document.addEventListener('DOMContentLoaded', function() {
    const logoutLink = document.querySelector('a[href="/logout"]');
    if (logoutLink) {
        logoutLink.addEventListener('click', handleLogout);
    }
});
</script>
<script>
function toggleRow(cell) {
    const row = cell.closest('tr');
    const expandedRow = row.nextElementSibling;

    if (expandedRow.classList.contains('hidden')) {
        expandedRow.classList.remove('hidden');
        cell.textContent = '-';
    } else {
        expandedRow.classList.add('hidden');
        cell.textContent = '+';
    }
}
</script>

<script>
// Right Sidebar Hover Effect
const rightSidebar = document.getElementById('rightSidebar');
document.body.addEventListener('mousemove', (event) => {
    if (event.clientY >= 100 && event.clientY <= 230 && event.clientX > window.innerWidth - 50) {
        rightSidebar.classList.remove('translate-x-full');
    } else {
        rightSidebar.classList.add('translate-x-full');
    }
});

// Chart Data
document.addEventListener('DOMContentLoaded', function() {
    // Get data from Django template context
    const statusCounts = {
        total: {{ total_tickets|default:0 }},
        open: 0,
        waiting: 0,
        pending: 0,
        resolved: 0,
        closed: 0,
        onHold: 0,
        initial: 0
    };

    // Process ticket_status_counts from Django
    {% for status in ticket_status_counts %}
        switch ('{{ status.status }}') {
            case 'open':
                statusCounts.open = {{ status.count }};
                break;
            case 'waiting_on_customer':
                statusCounts.waiting = {{ status.count }};
                break;
            case 'pending':
                statusCounts.pending = {{ status.count }};
                break;
            case 'resolved':
                statusCounts.resolved = {{ status.count }};
                break;
            case 'closed':
                statusCounts.closed = {{ status.count }};
                break;
            case 'on_hold':
                statusCounts.onHold = {{ status.count }};
                break;
            case 'initial_response':
                statusCounts.initial = {{ status.count }};
                break;
        }
    {% endfor %}

    // Today's data
    const todayData = {
        total: {{ todays_tickets|default:0 }},
        open: {{ open_tickets|default:0 }},
        closed: {{ closed_tickets|default:0 }}
    };

    // Pie Chart Configuration
    const doughnutData = {
        labels: ['Total Tickets', 'Open', 'Waiting On Customer', 'Pending', 'Resolved', 'Closed', 'On Hold', 'Initial Response'],
        datasets: [{
            label: 'Counts',
            data: [
                statusCounts.total,
                statusCounts.open,
                statusCounts.waiting,
                statusCounts.pending,
                statusCounts.resolved,
                statusCounts.closed,
                statusCounts.onHold,
                statusCounts.initial
            ],
            backgroundColor: [
                '#6c757d',    // Total - Gray
                '#ff9800',    // Open - Orange
                '#ffc107',    // Waiting - Yellow
                '#dc3545',    // Pending - Red
                '#007bff',    // Resolved - Blue
                '#007bff',    // Closed - Blue
                '#ffc107',    // On Hold - Yellow
                '#28a745'     // Initial Response - Green
            ],
        }]
    };

    // Bar Chart Configuration
    const barData = {
        labels: ['Today Tickets', 'Open Tickets', 'Closed Tickets'],
        datasets: [{
            label: 'Counts',
            data: [todayData.total, todayData.open, todayData.closed],
            backgroundColor: '#2196f3',
            borderRadius: 10,
        }]
    };

    // Chart Configurations
    const doughnutChartConfig = {
        type: 'doughnut',
        data: doughnutData,
        options: {
            responsive: true,
            plugins: {
                legend: {
                    position: 'bottom'
                }
            }
        }
    };

    const barChartConfig = {
        type: 'bar',
        data: barData,
        options: {
            responsive: true,
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        stepSize: 1
                    }
                }
            },
            plugins: {
                legend: {
                    display: false
                }
            }
        }
    };

    // Populate Data Table
    const tableBody = document.getElementById("dataTable");
    doughnutData.labels.forEach((label, index) => {
        let row = `<tr>
                    <td class="px-2 py-1 flex items-center">
                        <span class="w-4 h-4 inline-block rounded-full mr-2"
                              style="background-color: ${doughnutData.datasets[0].backgroundColor[index]};"></span>
                        ${label}
                    </td>
                    <td class="px-2 py-1 text-center">${doughnutData.datasets[0].data[index]}</td>
                </tr>`;
        tableBody.innerHTML += row;
    });

    // Initialize Charts
    const pieChart = new Chart(document.getElementById('pieChart').getContext('2d'), doughnutChartConfig);
    const barChart = new Chart(document.getElementById('barChart').getContext('2d'), barChartConfig);
});
</script>

<script>
    // Create a new file: static/employee/js/ticket-actions.js
class TicketActions {
    constructor() {
        this.csrfToken = document.querySelector('[name=csrfmiddlewaretoken]')?.value;
        this.initializeAcceptButtons();
    }

    initializeAcceptButtons() {
        document.querySelectorAll('.acknowledge-button').forEach(button => {
            button.addEventListener('click', (e) => {
                e.preventDefault();
                this.acknowledgeTicket(button.dataset.ticketId);
            });
        });
    }

    async acknowledgeTicket(ticketId) {
        try {
            const button = document.querySelector(`button.acknowledge-button[data-ticket-id="${ticketId}"]`);
            if (!button) return;

            // Show loading state
            button.disabled = true;
            button.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

            const response = await fetch(`/acknowledge-ticket/${ticketId}/`, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': this.csrfToken,
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                credentials: 'same-origin'
            });

            const data = await response.json();

            if (data.success) {
                // Update button cell
                const tdElement = button.closest('td');
                if (tdElement) {
                    tdElement.innerHTML = '<span class="text-success">✅</span>';
                }

                // Show success message
                Swal.fire({
                    icon: 'success',
                    title: 'Ticket Accepted',
                    toast: true,
                    position: 'top-end',
                    showConfirmButton: false,
                    timer: 3000
                });
            } else {
                throw new Error(data.error || 'Failed to acknowledge ticket');
            }
        } catch (error) {
            console.error('Error acknowledging ticket:', error);

            // Reset button state
            const button = document.querySelector(`button.acknowledge-button[data-ticket-id="${ticketId}"]`);
            if (button) {
                button.disabled = false;
                button.innerHTML = 'Accept';
            }

            // Show error message
            Swal.fire({
                icon: 'error',
                title: 'Error',
                text: 'Failed to accept ticket. Please try again.',
                toast: true,
                position: 'top-end',
                showConfirmButton: false,
                timer: 3000
            });
        }
    }
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', () => {
    window.ticketActions = new TicketActions();
});
</script>
{% endblock %}